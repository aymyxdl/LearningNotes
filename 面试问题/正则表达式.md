正则表达式

语法
/正则表达式主体/修饰符(可选)

var patt = /runoob/i

在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。

search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。

replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。


var str = "Visit Runoob!"; 
var n = str.search(/Runoob/i);


var str = document.getElementById("demo").innerHTML; 
var txt = str.replace(/microsoft/i,"Runoob");


====================

正则表达式修饰符
修饰符 可以在全局搜索中不区分大小写:

修饰符			描述
i				执行对大小写不敏感的匹配。
g				执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
m				执行多行匹配。


正则表达式模式
方括号用于查找某个范围内的字符：

表达式			描述
[abc]			查找方括号之间的任何字符。
[0-9]			查找任何从 0 至 9 的数字。
(x|y)			查找任何以 | 分隔的选项。


元字符是拥有特殊含义的字符：

元字符			描述
\d				查找数字。
\s				查找空白字符。
\b				匹配单词边界。
\uxxxx			查找以十六进制数 xxxx 规定的 Unicode 字符。




量词:

量词				描述
n+				匹配任何包含至少一个 n 的字符串。
n*				匹配任何包含零个或多个 n 的字符串。
n?				匹配任何包含零个或一个 n 的字符串。


------------------------------------


正则表达式表单验证实例：

/*是否带有小数*/
function isDecimal(strValue )  {  
   var  objRegExp= /^\d+\.\d+$/;
   return  objRegExp.test(strValue);  
}  

/*校验是否中文名称组成 */
function ischina(str) {
    var reg=/^[\u4E00-\u9FA5]{2,4}$/;   /*定义验证表达式*/
    return reg.test(str);     /*进行验证*/
}

/*校验是否全由8位数字组成 */
function isStudentNo(str) {
    var reg=/^[0-9]{8}$/;   /*定义验证表达式*/
    return reg.test(str);     /*进行验证*/
}

/*校验电话码格式 */
function isTelCode(str) {
    var reg= /^((0\d{2,3}-\d{7,8})|(1[3584]\d{9}))$/;
    return reg.test(str);
}

/*校验邮件地址是否合法 */
function IsEmail(str) {
    var reg=/^\w+@[a-zA-Z0-9]{2,10}(?:\.[a-z]{2,4}){1,3}$/;
    return reg.test(str);
}


-----------------------------------------

JavaScript RegExp 对象
RegExp 对象
正则表达式是描述字符模式的对象。

正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。

语法
var patt=new RegExp(pattern,modifiers);

或者更简单的方式:

var patt=/pattern/modifiers;
pattern（模式） 描述了表达式的模式
modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配






=======================================

传智播客.韩顺平.轻松搞定网页设计(html.css.javascript).第53讲.js正则表达式开山篇
传智播客.韩顺平.轻松搞定网页设计(html.css.javascript).第54讲.js正则表达式详解

视频中的匹配规则可以使用大括号，但是我在测试时中括号才有效
（看错了，用的是小括号）


g   global          全局匹配
i   ignoreCase      忽略大小写
m   multiLine       考虑换行


-------


RegExp.exec()

这个方法返回
成功：返回数组
失败：null


返回的数组不是所有结果，而是一个结果（如果有多次匹配，则多次返回数组）

数组中的第一个元素是当前 匹配的文本
后面的元素，则是其它规则

----

RegExp.test()

----

string.search(RegExp)

string.match(RegExp)

string.replace(RegExp, replaceText)
返回替换后的字符串

string.split()  //split函数不仅仅分割指定规则，也可以符合正则



-------


RegExp 静态属性
RegExp 类型包含一组静态属性，通过 RegExp 对象直接访问。这组属性记录了当前脚本中最新正则表达式匹配的详细信息，说明如表所示。
（这表示不需要正则对象，而是直接调用 RegExp.静态方法）

这些静态属性大部分有两个名字：长名（全称）和短名（简称，以 $ 开头表示）

比如index的用法（这个好像用不了）



-------

正则表达式的语法：   


1.子表达式，捕获，反向引用

var str = '_$#a&^9aa9)^(7agb'
var myReg = /(\d)(\w)\2\1/gi

上面这个表达式设计到： 子表达式，捕获，反向引用

子表达式： 每一个小括号就代表一个子表达式 
这里有两个： (\d) (\w)


反向引用： 引用其它表达式捕获的内容（反向引用的前提需要有个捕获的概念）
这里有2个反向引用： \2   \1
\2                      反向引用第一个表达式的内容   (\w)捕获的内容 a
\1                      反向引用第二个表达式的内容   (\d)捕获的内容 9

捕获： js引擎在匹配的时候，会把各个子表达式的内容捕获到内存中暂存


这里的内容是实际上匹配到的字符串，而不是规则
比如 abcd1dfa     （\d）是规则     而 1 是捕获的内容





var regStr = /(\d)(\d)\2\2\1/gi;
var regStr = /(\d){5}-(\d)\2\2(\d)\3\3(\d)\4\4/gi;
var regStr = /(\d){5}-((\d)\3\3){3}/gi;     //这样是上面的简写，但是要注意，第二个(\d)相当于第三个子表达式了，因为它也在括号里面

var str = 'aasadfsaf546asfdfs1122334443-1112223333sdf2';



2.元字符


1.限定符
2.选择匹配符
3.分组组合和反向引用符
4.特殊字符
5.字符匹配符
6.定位符



1.限定符
用于指定其前面的字符和组合项连许出现多少次
{n}   n表示次数

a{2}    4{4}    (\d){3}

1{3} 如果  1111111出现什么情况
只匹配两次 111 111 最后一个1没匹配，舍弃
即从匹配项的结尾开始下一次匹配

-----

{n,m} 表示前面的最少出现n次，最多m次


1{3,5}  a{1,2} (\d){3,9}

1{3,5} 如果 1111111出现什么情况
只匹配一次 11111 后面2个1没匹配

1{3,4} 如果 1111111出现什么情况
会匹配两次 1111 111
遵循贪婪匹配原则，尽可能匹配多的次数


-----

+   表示出现1次到任意次数

/a+/gi      /1+/gi      /ab+/gi


也是遵循贪婪匹配原则


-----

*   表示出现0次到任意次数


-----

?   表示出现0次到1数




=============


字符匹配符

[a-z]   表示可以匹配a-z中的任意一个字符
[A-Z]
[0-9]

[^a-z]  表示匹配不是a-z中的任意一个字符
[^A-Z]
[^0-9]

[abcd]  表示可以匹配abcd中的任意一个字符
[^abcd]



=============

定位符

^直接写表示定位符 
包在中括号里面才表示非

^       表示匹配目标字符串的开始位置

/^han/gi    hanafdfhan han han

$       表示匹配目标字符串的开始位置

/han$/gi    hanafdfhan han han


\b      目标字符串的边界

/han\b/gi   ahanhann han hana hhan

这个只会匹配到 han hhan
因为边界指的是 子串间有空格，或者是 目标串的结束位置
特别注意，没有起始位置
（这个我本来想测试一下，但是RegExp.index貌似没起作用）

\B      目标字符串的非边界




=============

选择匹配符

|       匹配某个字符串的时候是选择性的，即：既可以是这个，也可以是那个

/(han|韩)/gi     hanshunpingab 韩曙平




案例：写一个电子邮件的正则表达式


1.只能用一个@
2.@前面可以是a-z，A-Z，0-9，_，-
3.以.com或者.cn结尾


var myReg = /^[A-z0-9_-]+@([A-z]+\.)+(com|cn)$/gi



