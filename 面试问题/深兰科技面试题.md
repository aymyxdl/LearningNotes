# vue2 和 vue3 的区别在哪里

1.vue3中设计了组合api  composition API 代替了 之前vue2的 option API，复用性更强了

vue2的时候，代码要分别写在 data,methods,watch,computed 里面
而vue3只要直接写在setup中就行，很多时候，就不用写重复的代码了

2.更好的支持TS

3.最主要，vue3使用 Proxy 配合 Reflect 代替了vue2的 Object.defineProperty() 方法实现数据的响应式(数据代理)

4.重写了虚拟DOM，速度更快了

5.新的组件：Fragment(片段) / Teleport(瞬移) / Suspense(不确定)

6.设计了新的脚手架工具：vite，启动更快，打包更小



# 百度地图开发经验




# vue2 data 为什么要定义成一个函数

组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，
而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的


如果是一个对象的话，那所有的组件都是共用这个对象的
而data通过函数（实际上是闭包）返回，每个组件都是相互不影响的独立的作用域





# vuex 和 localstorage 有什么区别

1.最重要的区别：vuex 中的数据是存储在内存中的，页面刷新就会丢失；
而 localstorage 则是存储在计算机本地，刷新并不会丢失；sessionStorage 生存于应用会话期间。

2.应用场景：vuex用于组件之间的传值,（响应式的），
localstorage则主要用于不同页面之间的传值（其他页面更新数据了，当前页面要刷新才能相应更新，非响应式的）

3.永久性：vuex全局变量存储，当刷新页面时vuex存储的值会丢失（存在内存里的，刷新了，当然会丢失），
localstorage不会。



状态管理设计的目的并不是用于做缓存，而是用来作为唯一数据源，同步状态，共享状态。
所以从功能上讲，区别很大。
你每在一个组件用到storage中的数据，你就要搞一份数据用于同步视图。
想想看，直接改storage并不会让视图有任何更新，你必须将storage中的数据parse出来，并且在组件内同步data与storage。
并且你在A组件改变storage的数据，并不能让另一个用到其中数据的B组件的数据得到更新。

而vuex则可以帮助你响应式的更新这些数据和视图



# vuex 是存在哪里的？定义的一些全局变量是存放在哪里

内存中

# vue 的路由导航守卫，相对应的几个钩子

三种导航守卫

1.全局导航守卫：（在引入路由的时候进行配置）

router.beforeEach()
router.afterEach()

前置守卫：一般会用来判断用户是否登录，未登录则跳转登录页
后置守卫：和beforeEach不同的是afterEach不接收第三个参数 next 函数，也不会改变导航本身




二、路由独享的守卫（路由配置页面可以给每条路由进行配置）
beforeEnter 


三、组件内的守卫

beforeRouteEnter
beforeRouteUpdate
beforeRouteLeave


// 跟methods: {}等同级别书写，组件路由守卫是写在每个单独的vue文件里面的路由守卫
beforeRouteEnter (to, from, next) {
  // 注意，在路由进入之前，组件实例还未渲染，所以无法获取this实例，只能通过vm来访问组件实例
  next(vm => {})
}
beforeRouteUpdate (to, from, next) {
  // 同一页面，刷新不同数据时调用，
}
beforeRouteLeave (to, from, next) {
  // 离开当前路由页面时调用
}



# v-if 和 v-show 的不同
基于vue框架
v-if：当隐藏结构时该结构会直接从整个dom树中移除；

v-show：当隐藏结构时是在该结构的style中加上display:none，结构依然保留


什么时候使用v-if，什么时候使用v-show?
当组件中某块内容只会显示或隐藏不会被再次改变显示状态，此时用v-if更加合适，
例如请求后台接口通过后台数据控制某块内容是否显示或隐藏，且这个数据在当前页不会被修改；

当组件某块内容显示隐藏是可变化的，此时用v-show更加合理，例如页面中有一个toggle按钮,点击按钮来控制某块区域的显示隐藏。

为什么这么说呢？大家都知道频繁操作dom对性能影响很大，v-if如果用在有toggle按钮控制的情况下，相当于在频繁增加dom和删除dom，所以此时用v-show更加合适

如果只是要么显示要么隐藏之后不会再改变显示隐藏状态的情况，v-if更加的合理，
因为如果默认就是隐藏，相当于dom一次都不用创建，如果默认是显示，v-if和v-show效果完全一样。





# v-show 里面组件的生命周期是怎样的
比如 v-show 里面的一个子组件，或者弹窗，它的生命周期是怎样的


对生命周期的影响
v-if - 初始渲染：

初始值为 false 组件不会渲染，生命周期钩子不会执行，v-if 的渲染是惰性的。
初始值为 true 时，组件会进行渲染，并依次执行 beforeCreate,created,beforeMount,mounted 钩子。

v-if - 切换：

false => true：依次执行 beforeCreate, created, beforeMount, mounted 钩子。
true => false：依次执行 beforeDestroy, destroyed 钩子。

v-show - 渲染：

无论初始状态，组件都会渲染，依次执行 beforeCreate, created, beforeMount, mounted 钩子，v-show 的渲染是非惰性的。

v-show - 切换：

对生命周期钩子无影响，切换时组件始终保持在 mounted 钩子。



# 函数防抖的应用场景和实现方式

函数防抖
在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。


优化前直接用setTimeout 方式来实现

优化后，用闭包的方式来实现防抖（解决传参和封装防抖函数的问题）



应用于比如鼠标移动监听，或者点击执行js，点击执行后台请求等场景



---

函数节流
每隔一段时间，只执行一次函数。


函数节流的目的，是为了限制函数一段时间内只能执行一次。
因此，定时器实现节流函数通过使用定时任务，延时方法执行。
在延时的时间内，方法若被触发，则直接退出方法。从而，实现函数一段时间内只执行一次。






# canvas是否画过 限定的建筑类 的图像

# canvas的性能如何去优化，就比如很多点，线，要去加载（几十上百M）
加载再放大，再加载（需要一些延迟加载技术）

# 规则引擎，客户引擎 前端编辑页面的功能
自定义一些组件，流向，状态机之类的
可以推拽去编辑一些状态、流向的改变
然后去生成一个json体之类的格式文件

如果让你设计，你大概会怎么做

# 如果给你一个你没做过的新需要，你该如何去实现
是完全自己思考还是参考往上的一些功能
参考搜索的话回去哪里搜索
然后如何提炼这个需求的关键字去进行搜索

# 小程序一些蓝牙接口之类的数据读取功能是否做过

# 混合开发，uniapp是否用过，uniapp 和 原生的有哪些差别

# uniapp开发中遇到过哪些坑

# 线上的bug是如何去定位和解决的
面试官想问的是，热部署去解决线上的一些bug
因为安卓这边可以做热部署，一些小的文件可以直接打包扔上去就行

# 音视频开发经验

比如一些 WebRTC 方案，因为自动驾驶，地图导航里面也会需要用到音视频



开发过websocket



# ios一般用什么开发














