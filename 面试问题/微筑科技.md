## webpack有哪些核心概念


webpack主要包括6个核心概念：
1，Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。
2，Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
3，Chunk：代码块，一个 Chunk 由多个模块组合而成的抽象概念，用于代码合并与分割。
4，Loader：模块转换器，用于把模块原内容按照需求转换成新内容。
5，Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。
6，Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。



## webpack如何实现按需加载

import() 这个语句就能实现按需加载（返回的是promise）
import().then()


其实还有一种（总共有两种按需加载的方式）
还有一个就是webpack的 require.ensure()实现按需加载




代码中最关键的一句是  import(/* webpackChunkName: "show" */ './show') ，
Webpack 内置了对  import(*)  语句的支持，当 Webpack 遇到了类似的语句时会这样处理：

以  ./show.js  为入口新生成一个 Chunk；

当代码执行到  import  所在语句时才会去加载由 Chunk 对应生成的文件。

import 返回一个 Promise，当文件加载成功时可以在 Promise 的  then  方法中获取到  show.js  导出的内容。

在使用 import() 分割代码后，你的浏览器并且要支持 Promise API 才能让代码正常运行， 
因为 import() 返回一个 Promise，它依赖 Promise。对于不原生支持 Promise 的浏览器，你可以注入 Promise polyfill。

/* webpackChunkName: "show" */  的含义是为动态生成的 Chunk 赋予一个名称，以方便我们追踪和调试代码。 
如果不指定动态生成的 Chunk 的名称，默认名称将会是  [id].js。 /* webpackChunkName: "show" */  
是在 Webpack3 中引入的新特性，在 Webpack3 之前是无法为动态生成的 Chunk 赋予名称的。

为了正确的输出在  /* webpackChunkName: "show" */  中配置的 ChunkName，还需要配置下 Webpack，配置如下：


其中最关键的一行是  chunkFilename: '[name].js ',，它专门指定动态生成的 Chunk 在输出时的文件名称。 
如果没有这行，分割出的代码的文件名称将会是  [id].js 。





## js中模块有几种加载方式

问的问题可能包含两方面

一方面是 es6的 import export
node 的 require
或者es5的 立即执行函数

这种模块加载


另一方面可能是想问这种

es的暴露 分为几种:
  分别暴露
  统一暴露
  默认暴露


import的方式
  1.通用的导入方式
    import * as m1 from 'xxx.js'; // 这里把 js 整个文件整合成了 m1 对象,里面的方法属性同过 m1. 调用

  2.解构赋值形式
    import {xx as aa, xxx} from 'xxx.js'; // xxx.js 一般是 分别暴露或者统一暴露,这样解构赋值的形式把 那些属性,方法 对号入座 拆解开来

  3.简便形式: 只针对默认暴露
    import xx from 'xx';



## es6如何实现按需加载

es6的import和export是静态加载
而且es6里面无法做按需加载（我感觉是面试官自己也弄错了）


或许他想问的是动态加载

import().then(_ => {})

静态加载、动态加载、同步加载、异步加载

动态加载和静态加载指的是什么时候加载，动态加载是运行时加载（CommonJS），静态加载是编译(预编译)时加载（ES6）。当然es6也提供的动态加载，即import() 。

动态加载：require() 、import()
静态加载：import

同步加载还是异步加载指的是加载的方式。 静态加载中都是同步加载的。动态加载中CommonJS的require是同步的。而es6import()是异步的。

同步加载：require()
异步加载：import()、 require(['xxx'],() =>{})

同步加载很明显，会阻塞接下来的流程，异步加载不会。
普通的import语句( import Fuck form '../fuck.vue' )因为是预编译的时候，加载的，加载后会放到模块的最上面，然后接下来才是运行。
他都没有阻塞或不阻塞接下来的程序运行，所以他不属于同步加载，也不属于异步加载。(这句没搞懂，不是说是静态加载是同步的吗？)




## webpack中代码分离是怎么做的

代码分割
为了解决打包结果过大导致的问题，Webpack 设计了一种分包功能：Code Splitting（代码分割）。

Code Splitting 通过把项目中的资源模块按照我们设计的规则打包到不同的 bundle 中，从而降低应用的启动成本，提高响应速度。

Webpack 实现分包的方式主要有两种：

根据业务不同配置多个打包入口，输出多个打包结果；
结合 ES Modules 的动态导入（Dynamic Imports）特性，按需加载模块。



----

说实话，上面的这些 按需加载，懒加载，动态加载，异步加载，我都搞混了，不知道是啥东西了



vue异步组件懒加载(按需加载)
利用webpack对代码进行分割是懒加载的前提，懒加载就是异步调用组件，需要时候才下载（按需加载）。


为什么需要懒加载?
在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，
延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，
需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时



因此，vue为我们专门设立了异步组件，通过异步组件，我们可以得到两点好处：
1、 用不到的组件不会加载，因此网页打开速度会很快，当你用到这个组件的时候，才会通过异步请求进行加载；
2、 缓存组件，通过异步加载的组件会缓存起来，当你下一次再用到这个组件时，丝毫不会有任何的疑迟，组件很快会从缓存中加载出来。


异步组件=原理同webpack的按需加载
好处：
1）按需加载，可以节省首次加载时间，提高速度，性能优化
2）第一次加载完成会缓存


异步组件的描述：
Vue允许将组件定义为一个异步解析（加载）组件定义的工厂函数，
即Vue只在实际需要渲染组件时，才会触发调用工厂函数，并且将结果缓存起来，用于将来再次渲染。


ps:要使用异步组件，一个比较推荐的方式就是配合webpack代码分离功能。




----


webpack中利用require.ensure()实现按需加载  js （其实有两种）
require.ensure()(webpack异步加载|代码分割)












