# js的垃圾回收机制

一、内存泄漏
定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。
js中可能出现的内存泄漏情况：结果：变慢，崩溃，延迟大等

js中可能出现的内存泄漏原因：
  全局变量过多
  dom 清空时，还存在引用
  定时器未清除
  子元素存在引起的内存泄露



-----


二、JS垃圾回收机制是怎样的？

1.概述

js的垃圾回收机制是为了防止内存泄漏（已经不需要的某一块内存还一直存在着），
垃圾回收机制就是不停歇的寻找这些不再使用的变量，并且释放掉它所指向的内存。
在JS中，JS的执行环境会负责管理代码执行过程中使用的内存。


2.变量的生命周期

当一个变量的生命周期结束之后，它所指向的内存就会被释放。
js有两种变量，局部变量和全局变量，
局部变量是在他当前的函数中产生作用，当该函数结束之后，该变量内存会被释放，全局变量的话会一直存在，直到浏览器关闭为止。




3.js垃圾回收方式
有两种方式： 标记清除、引用计数(其实还有很多种)

标记清除：
大部分浏览器使用这种垃圾回收，当变量进入执行环境(声明变量）的时候，垃圾回收器将该变量进行了标记，
当该变量离开环境的时候，将其再度标记，随之进行删除。


引用计数：
这种方式常常会引起内存的泄露，主要存在于低版本的浏览器。
它的机制就是跟踪某一个值得引用次数，当声明一个变量并且将一个引用类型赋值给变量得时候引用次数加1，当
这个变量指向其他一个时引用次数减1，当为0时出发回收机制进行回收。





-----


三、垃圾回收

JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。

当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它?



1.可达性
JavaScript 中内存管理的主要概念是可达性。
简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。


  1). 有一组基本的固有可达值，由于显而易见的原因无法删除。例如:
    本地函数的局部变量和参数
    当前嵌套调用链上的其他函数的变量和参数
    全局变量
    还有一些其他的，内部的

  这些值称为根。

  2). 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。

      例外: 如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。


2.内部算法(Mark-Sweep)

  基本的垃圾回收算法称为“标记-清除”，定期执行以下“垃圾回收”步骤:

    垃圾回收器获取根并“标记”(记住)它们。
    然后它访问并“标记”所有来自它们的引用。
    然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
    以此类推，直到有未访问的引用(可以从根访问)为止。
    除标记的对象外，所有对象都被删除。


  这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。

  一些优化:

    分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。
      那些活得足够久的对象，会变“老”，并且很少接受检查。

    增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。
      因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。

    空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。


-----

四、面试怎么回答

1）问什么是垃圾
一般来说没有被引用的对象就是垃圾，就是要被清除，有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

2）如何检垃圾
一种算法是标记 标记-清除 算法，还有引用计数法



-----

五、V8引擎的垃圾回收机制

v8引擎使用 分代式垃圾回收。
将对象分为新生代(新对象，存活时间较短)、老生代(老对象，存活时间较长)

新生代使用 scavenge 算法：from to两个区域，存活下来的放到to，一次垃圾回收后再放回from，循环往复，多次存活后可以晋升老生代区。


对象晋升的条件主要有以下两个（满足其一即可）：
对象是否经历过一次Scavenge算法
To空间的内存占比是否已经超过25%




老生代对象先使用 标记-清除 算法(就是上面讲到的Mark-Sweep).
但是：  
  但是经过标记清除之后的内存空间会⽣产很多不连续的碎⽚空间，这种不连续的碎⽚空间中，在遇到较⼤的对象时可能会由于空间不⾜⽽导致⽆法存储。
  (意思就是一片大小为9的内存区域中，本来是有9个对象存在：假设他们每个占用1的内存，并且按顺序排列，
  经历了标记-清除算法之后，只有159这三个对象存活了下来，但是他们是分散的排列在这个大小为9的内存区域中，如果需要新增一个大小为4的对象，
  就会因为连续空间大小不够4，而导致这个对象不能存放在这片内存中，这个空间，就叫做碎片空间)
  为了解决内存碎⽚的问题，需要使⽤另外⼀种算法：标记-整理（Mark-Compact）。


其实使用 标记-清除 后，这个时间，垃圾还没有回收，他们只是被标记了，还需要用 标记-整理 来重新规划内存区，来释放碎片空间，进行优化。

标记-清理：在进行 标记-清除 这个算法的标记阶段之后，已经标记出了这片大小为9的内存中，159可以存活，
  这个时候，执行标记-整理，把159移动到一片新的内存中，这个就是标记-整理。

这个时候，最后执行标记-清除的 清除阶段：这个清除，就把1-9位置的空间全部清除掉(因为159已经挪走了)，这片空间就被完整的释放出来了。
