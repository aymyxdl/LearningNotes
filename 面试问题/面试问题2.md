(√)语法糖
(√)构造器和构造函数
(√)new操作符干了些什么
(√)call() apply() bind()
(√)问题：new person . new person()有什么区别		
(√)a => a+1 	、 	a => {a+1} 这两个分别是什么意思
(√)对象字面量 字面量对象
(√)原型和原型链
(√)重写原型（p.__proto__ === p.constructor.prototype  false的问题）
(√)继承（原型继承）
JS设计模式————原型模式
window.onload=init
instanceof


(√)块级作用域
(√)ES6新特性
(√)ES 6的 class（类） （答案在 ES6新特性）
(√)可枚举



Object.constructor //对象的构造函数

Object.hasOwnProperty() //检查对象属性是否被继承

Object.isPrototypeOf() //检查一个对象是否是另外一个对象的原型

Object.propertyIsEnumerable() //是否可以通过for/in 循环看到属性

Object.toLocaleString() //返回对象的本地字符串表示

Object.toString() //定义一个对象的字符串表示

Object.valueOf() //制定对象的原始值




传递给函数的隐含参数：arguments
arguments 对象的另一个属性是 callee，它表示对函数对象本身的引用
函数的 apply、call 方法和 length 属性


实际上，JavaScript所有的固有数据类型都具有只读的prototype属性（因为如果修改了这些类型的prototype属性，则哪些预定义的方法就消失了


函数声明		函数表达式


VUEJS


stylus
keep-alive
修改了数据，页面没有响应刷新
组件之间的传值
插槽(slot)是什么
<router-view> 和 <router-link>标签
Vue面试中，经常会被问到的面试题/Vue知识点整理
vue.js面试题整理




=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


问：对象字面量


答：



我们知道JavaScript中的数据类型有基本数据类型和引用类型，
其中Object类型就是非常常用的类型。
那么如果创建一个Object类型的实例呢？下面我介绍两种方法：

第一：构造函数法。

var person=new Object();
person.name="zhuzhenwei";
person.age=20;

这里Object（）实际上是默认的构造函数，显然，为满足需要，我们可以通过后两条语句添加新的属性。
JavaScript高级程序设计第3版83页介绍说，该构造函数为新对象定义了默认的属性和方法。
但，这是真的吗？我们可以验证一下。因为for-in语句可以遍历对象中所有的属性，因此我们可用它来验证：

var person=new Object();
for(var propName in person){
   console.log(propName);
}
如果Object构造函数有默认属性，那么我们在控制台上应该是可以看到的，但实际上：什么都没有？


也就是说Object本身是不具有任何默认的属性的。

因为如果我们添上后面两句：

var person=new Object();
person.name="zhuzhenwei";
person.age=20;
for(var propName in person){
	console.log(propName);
}

我们就可以得到如下：

name
age
即此时person就有了两个属性，也就是说，Object函数自身确实没有默认的属性。
但是，真的是这样吗？javascript高级程序设计会出现这样的错误吗？答案是不会~

因为在这里使用for-in语句是不合适的，不能通过它枚举初object的所有属性。
它只适用于window之类的对象，这里我们最好使用in操作符。因为object通过测试是不可枚举的。 
alert(object.propertyisenumerable("prototype"));//false

var person=new Object();
console.log("toString" in person);//true
console.log("valueOf" in person);//true
console.log("constructor" in person);//true
也就是说Object至少是有上述属性和方法的。


第二：对象字面量表示法

var person={
    name: '123',
    age: 19
};

这里也创建了一个对象实例，同样通过for-in语句，我们可以验证其也只有name和age两个属性，
且在通过对象字面量表示法定义对象时，实际上不会调用Object构造函数。 

关于对象字面量有以下一点需要注意的地方：

在末尾需加分号;表示结束。
在一个属性定义之后用逗号分隔,最后一个属性不需要
属性名可以加双引号，好处是我们可以包含错误的字符。
并使用方括号表示法来访问对象的属性。

比如：

var person=new Object();
person.age age=18;
console.log(person.age age);
这时，由于属性名中包含了空格，因此得到的结果一定是 语法错误。

然而：

var person={
      "age age":18
};
 console.log(person["age age"]);
这时候我们就可以得到正确的答案了。

第二部分：

什么使数组字面量呢？对象字面量用于创建对象，数组字面量即用于创建数组。创建数组有两种方法。

第一：构造函数法.
var arr=new Array();

第二：数组字面量法

var arr=["zhu","zhen","wei"];

因为所有的引用类型都是继承自Object，因此Array也是继承自object的，并在继承的基础上添加了自己的属性和方法。

var arr=new Array();
console.log("toString" in arr);//true
console.log("valueOf" in arr);//true
console.log("length" in arr);//true


https://www.jianshu.com/p/17b8b3b28eae


=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


问：可枚举


答：


JavaScript对象的属性可分为可枚举和不可枚举，它是由属性的enumeration值决定的，true为可枚举，false为不可枚举
js中原型属性一般是不可枚举的，而自己定义的属性一般是可枚举的
可以通过propertylsEnumerable()方法判断该属性是否可枚举

属性的枚举性会影响以下三个函数的结果  （ES6标准入门P164有写这三种的区别）
1)for...in  					//遍历原型与实例上的所有可枚举属性
2)Object.keys();  				//只能返回对象本身具有的可枚举属性。
3)JSON.stringify();  			//只能读取对象本身的可枚举属性，并序列化为JSON对象。
4)Object.getOwnPropertyNames() 	//遍历自身所有属性（不论是否是可枚举的）,不包括原型链上面的.。
5)Object.assign()  es6新增  		//自身的可枚举属性。

es6有五种方法遍历对象的属性P165


上面说了JavaScript对象的属性是否可枚举是由enumeration的值决定的，
那么enumeration是什么，它的值又是什么时候去设置的呢？

enumeration是 Object.defineProperty()方法的一个参数，下面来看看怎么去设置 一个属性是否可枚举。


var person = {
    name:'zhou',
    age: '12',
    sex: 'girl'
}
 
Object.defineProperty(person,'age',{
    enumerable:true,//可以被枚举
});
Object.defineProperty(person,'sex',{
    enumerable:false,//不可被枚举
})
 
for(var k in person){
    console.log(person[k])
}
//zhou
//12


如何设置是否可枚举-- enumerable
由上面的点可以看出：
1.Object.defineProperty(obj, prop, descriptor)方法有三个参数，每个参数各代表着
　　第一个：目标属性所在的对象，
　　第二个：目标属性，放在字符串里，
　　第三个：目标属性的行为，放在对象里；
2.enumerable为true表示可枚举，enumerable为false表示不可枚举；
3.开发者自定义的对象person的所有属性都是可枚举的；


如何判断是否可枚举-- propertyIsEnumerable
在不知情的情况下，我们如何判断一个属性是否可枚举呢？propertylsEnumerable()方法可以解决这个问题，
对于上面的例子来看看他是怎么用的

person.propertyIsEnumerable('sex');//false
person.propertyIsEnumerable('age');//true
propertyIsEnumerable() 语法

1.语法：obj.propertyIsEnumerable(prop)
2.描述：每个对象都有一个propertyIsEnumerable方法。此方法可以确定对象中指定的属性是否可枚举，返回一个布尔值。
但该方法对通过原型链继承的属性无效(原型链继承的属性是否可枚举不能用该方法来判断)
3.案例：
1)用户自定义对象和引擎内置对象的区别


var o = {};
var a = [];
o.prop = 'is enumerable';
a[0] = 'is enumerable';
o.propertyIsEnumerable('prop');   //  返回 true
a.propertyIsEnumerable(0);  //  返回 true
 
 
Math.propertyIsEnumerable('random');   // 返回 false
Object.propertyIsEnumerable('constructor');    // 返回 false
对于基本包装类型的原型属性是不可枚举的，如Object, Array, Number等

var num = new Number();
for(var pro in num) {
    console.log("num." + pro + " = " + num[pro]);
}
它的输出结果会是空。这是因为Number中内置的属性是不可枚举的，所以不能被for…in访问到

说明开发者自定义的属性在一般情况下是可枚举的，
而内置特殊对象Math和基本包装类型的原型属性是不可枚举的，如Object, Array, Number等


2）自身属性和继承属性

//构造函数
function firstConstructor() {
  this.property = 'is not enumerable';
}
firstConstructor.prototype.firstMethod = function() {};
 
//继承
function secondConstructor() {
  this.method = function method() { return 'is enumerable'; };
}
secondConstructor.prototype = new firstConstructor;
secondConstructor.prototype.constructor = secondConstructor;
 
//实例
var o = new secondConstructor();
o.arbitraryProperty = 'is enumerable';
//打印出实例
console.dir(o)
我们来看看打印出来的实例对象，看看那些那些属性是自身的，那些属性是在原型上的

最后来看看这些属性在propertyIsEnumerable()上返回的值

console.log(o.propertyIsEnumerable('arbitraryProperty')); // 返回 true
console.log(o.propertyIsEnumerable('method')); // 返回 true
 
console.log(o.propertyIsEnumerable('prototype')); // 返回 false
console.log(o.propertyIsEnumerable('constructor')); // 返回 false
console.log(o.propertyIsEnumerable('firstMethod')); // 返回 false
说明propertyIsEnumerable方法只对对象自身的属性(对象自身添加的、构造函数实例化的)有效，对原型上的、继承来的属性都无效。
例如图二的属性丢失可枚举的，但是在原型上的属性propertyIsEnumerable()方法却都返回false，所以该方法对其无效。


https://blog.csdn.net/weixin_40374953/article/details/85319512


=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


问：块级作用域


答：
ES6中啥是块级作用域？运用在哪些地方？

在了解这两个API前，我们先了解一下块级作用域这个概念。

定义：是一个语句，将多个操作封装在一起，通常是放在一个大括号里，没有返回值。

为何需要块级作用域?

在ES6之前，函数只能在全局作用域和函数作用域中声明，不能在块级作用域中声明。没有块级作用域导致很多场景不合理：

1、内存变量可能覆盖外层变量

var a = 33;
function test() {
  console.log(a)
  if(false) {
    var a = 'eee'; 		//这里用到是var，在整个函数执行前，会先把变量放到最前面
  }
}
test();  // undefined
输出的结果为undefined，是因为变量提升导致内层的 a 变量覆盖了外层的 a 变量。


2、用来计数的循环变量泄露为全局变量
for (var i = 0; i < 10; i++) {    
        console.log(i);    
}    
console.log(i);  // 10  
上面的变量i 只是用来控制循环，但是循环之后，并没有消失，而是泄露为全局变量了。
因为var 不存在块级作用域，所以变成了全局变量


-----

ES6中的块级作用域：
1、允许块级作用域任意嵌套，外层作用域无法读取内层作用域的变量

{{{{  
    {let i = 6;}  
    console.log(i);  // 报错  
}}}}  


2、内层作用域可以定义外层作用域的同名变量

{{{{  
    let i = 5;  
    {
        let i = 6;
        console.log(i) 		//i = 5，被覆盖了，变成了 i = 6
    }
    console.log(i)  		//但是这里还是5，因为let是块级作用域
}}}}  


3、不需要立即执行匿名函数

立即执行函数：
(function() {
  var  a = 0;
}());

块级作用域：

{
    let a = 0;
}

//这里的解释应该配合下面的数组方法使用才更明确，不然有点模糊不清


块级作用域中的函数声明
运行环境：ES6浏览器。
可实现的行为：
1、允许在块级作用域内声明函数
2、函数声明类似于var， 即会提升到全局作用域或函数作用域的头部
3、函数声明还会提升到所有块级作用域的头部


---------------------------------------开始----------------------------------------------


function func() {  
    console.log('out');  
}  
(function() {  
    var func = undefined;  
    if (false) {  						//如果进了if判断，则会打印 in
        function func() {   			//如果没进if判断，则会报错，func is not a function
            console.log('in');  		//因为 var func = undefined; 
        }  
    }  
    func();  
})(); 



考虑到环境导致的差异太大，应该避免在块级作用域中声明函数，如果需要，应该写成函数表达式的形式，而不是函数声明语句：

let func= function func() {  
    console.log('in');  
}; 

//这一段说明举例没有看懂


---------------------------------------结束----------------------------------------------

ES6的块级作用域允许声明函数的规则只在使用大括号的情况下成立：

'use strict':  
if (true) {  
    function func1() {} // 不报错  
}  
if (true)  
    function func2() {} // 报错  

-----

在了解完块级作用域后，我们来看看 let 命令：

什么是 let ？
let 是ES 用于声明变量的命令，与 var 类似，与之不同的是：
1、let 声明的变量只在块级作用域内有效
2、不存在变量提升，而是“绑定”在暂时性死区
3、不能重复声明



let 声明的变量只在块级作用域内有效

'use strict';
function func(args){
    if(true){
        let i = 6;
        console.log('inside: ' + i);  //不报错
    }
    console.log('outside: ' + i);  // 报错 "i is not defined"
};
func();



不存在变量提升，而是“绑定”在暂时性死区

// 不存在变量提升
'use strict';
function func(){
    console.log(i);
    let i;
};
func(); // 报错


在let声明变量前，使用该变量，它是会报错的，而不是像var那样会‘变量提升’。
其实说let没有‘变量提升’的特性，不太对。或者说它提升了，但是ES6规定了在let声明变量前不能使用该变量。

'use strict';
var test = 1;
function func(){
    console.log(test);
    let test = 2;
};
func();  // 报错

如果let声明的变量没有变量提升，应该打印’1’（func函数外的test）；
而它却报错，说明它是提升了的，只是规定了不能在其声明之前使用而已。
我们称这特性叫“暂时性死区（temporal dead zone）”。且这一特性，仅对遵循‘块级作用域’的命令有效（let、const）。



let使用经典案例：let命令代替闭包功能
闭包实现：

var arr = [];
for(var i = 0; i < 2; i++){
    arr[i] = (function(i){
        return function(){
            console.log(i);
        };
    }(i));
};
arr[1]();
let 实现：

'use strict';
var arr = [];
for(let i = 0; i < 2; i++){
    arr[i] = function(){
        console.log(i);
    };
};
arr[1]();

//这里就是配合上面的 	3、不需要立即执行匿名函数


剩下 const 命令了！
const 与 let 的使用规范一样，与之不同的是：
const 声明的是一个常量，且这个常量必须赋值，否则会报错。

'use strict';
function func(){
    const PI;
    PI = 3.14;
    console.log(PI);
};
func(); // 报错“Missing initializer in const declaration”
let 和 const 就介绍到这，下期介绍变量的解构。

https://www.jianshu.com/p/492c660c9374




=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


问：vue.js面试题整理

答：


一、对于MVVM的理解？

MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。

Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；
View 代表UI 组件，它负责将数据模型转化成UI 展现出来，
ViewModel 是一个同步View 和 Model的对象（桥梁）。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，
Model 和 ViewModel 之间的交互是双向的， 
因此View 数据的变化会同步到Model中（input），而Model 数据的变化也会立即反应到View 上。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，
而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，
因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。


二、mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？

mvc和mvvm其实区别并不大。都是一种设计思想。
主要就是mvc中Controller演变成mvvm中的viewModel。
mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。

区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多的场景，更加便捷


三、vue的优点是什么？

低耦合。视图（View）可以独立于Model变化和修改，
一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。

可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。

独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。

可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。


四、组件之间的传值？（其它已有）

五、路由之间跳转


1.直接修改地址栏中的路由地址 
2.通过router-link实现跳转
<router-link='/app'>jump to app</router-link>

3.通过js的编程的方式
this.$router.push('/myLogin')
//这种方式不太了解


六、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？

第一步：在components目录新建你的组件文件（如：indexPage.vue），script一定要export default {}

第二步：在需要用的页面（组件）中导入：import indexPage from '@/components/indexPage.vue'

第三步：注入到vue的子组件的components属性上面,components:{indexPage}

第四步：在template视图view中使用，
例如有indexPage命名，使用的时候则index-page

(说白了就是 export import)



七、vue如何实现按需加载配合webpack设置

webpack中提供了require.ensure()来实现按需加载。
以前引入路由是通过import 这样的方式引入，改为const定义的方式进行引入。

不进行页面按需加载引入方式：import home from '../../common/home.vue'

进行页面按需加载的引入方式：const home = r => require.ensure( [], () => r (require('../../common/home.vue')))


在音乐app中使用的路由懒加载方式为：

复制代码
const Recommend = (resolve) => {
  import('components/recommend/recommend').then((module) => {
    resolve(module)
  })
}

const Singer = (resolve) => {
  import('components/singer/singer').then((module) => {
    resolve(module)
  })
}


扩展：

vue项目实现按需加载的3种方式：vue异步组件、es提案的import()、webpack的require.ensure()

1. vue异步组件技术

vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。
但是，这种情况下一个组件生成一个js文件。
举例如下：

{
    path: '/promisedemo',
    name: 'PromiseDemo',
    component: resolve => require(['../components/PromiseDemo'], resolve)
},{
	path: '/home',
	name: 'home',
	component: resolve => require(['@/components/home'],resolve)
},{
	path: '/index',
	name: 'Index',
	component: resolve => require(['@/components/index'],resolve)
},{
	path: '/about',
	name: 'about',
	component: resolve => require(['@/components/about'],resolve)
}


2. es提案的import()
推荐使用这种方式(需要webpack > 2.4)
vue-router配置路由，代码如下：

// 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。
const ImportFuncDemo1 = () => import('../components/ImportFuncDemo1')
const ImportFuncDemo2 = () => import('../components/ImportFuncDemo2')

// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。
// const ImportFuncDemo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo')
// const ImportFuncDemo2 = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo2')

export default new Router({
    routes: [
        {
            path: '/importfuncdemo1',
            name: 'ImportFuncDemo1',
            component: ImportFuncDemo1
        },
        {
            path: '/importfuncdemo2',
            name: 'ImportFuncDemo2',
            component: ImportFuncDemo2
        }
    ]
})


3. webpack提供的require.ensure()

vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。
这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。
举例如下：

{
    path: '/promisedemo',
    name: 'PromiseDemo',
    component: resolve => require.ensure([], () => resolve(require('../components/PromiseDemo')), 'demo')
},
{
    path: '/hello',
    name: 'Hello',
    // component: Hello
    component: resolve => require.ensure([], () => resolve(require('../components/Hello')), 'demo')
}




八、vuex面试相关

1.vuex是什么？怎么使用？哪种功能场景使用它？

vue框架中状态管理。在main.js引入store，注入。
新建一个目录store，….. export 。
场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车

main.js:

import store from './store'


new Vue({
el:'#app',
store
})


2.vuex有哪几种属性？

有五种，分别是 State、 Getter、Mutation 、Action、 Module

vuex的State特性
A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data
B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中

vuex的Getter特性
A、getters 可以对State进行计算操作，它就是Store的计算属性
B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用
C、 如果一个状态只在一个组件内使用，是可以不用getters

vuex的Mutation特性
mutations定义的方法动态修改Vuex 的 store 中的状态或数据。

Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。


3.不用Vuex会带来什么问题？

可维护性会下降，想修改数据要维护三个地方；

可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；

增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。




九、 v-show和v-if指令的共同点和不同点

v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏

v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果

十、如何让CSS只在当前组件中起作用

将当前组件的<style>修改为<style scoped>

十一、<keep-alive></keep-alive>的作用是什么?

<keep-alive></keep-alive> 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。

十二、Vue中引入组件的步骤?

1）采用ES6的import ... from ...语法或CommonJS的require()方法引入组件
2）对组件进行注册,代码如下

// 注册
 Vue.component('my-component', {
	template: '<div>A custom component!</div>'
})


3）使用组件<my-component></my-component>

十三、指令v-el的作用是什么?

提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例

十四、在Vue中使用插件的步骤

采用ES6的import ... from ...语法或CommonJSd的require()方法引入插件

使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })

如使用懒加载插件：

Vue.use(VueLazyload, {
  loading: require('common/image/default.png')
})

十五、请列举出3个Vue中常用的生命周期钩子函数(其他已有)

十六、active-class是哪个组件的属性？

vue-router模块的router-link组件。

十七、怎么定义vue-router的动态路由以及如何获取传过来的动态参数？

在router目录下的index.js文件中，对path属性加上/:id。
使用router对象的params.id。

十八、vue-router有哪几种导航钩子？

三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
第二种：组件内的钩子；
第三种：单独路由独享组件


十九、生命周期相关面试题

总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。

创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。
在created阶段，vue实例的数据对象data有了，el还没有。

载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。
在mounted阶段，vue实例挂载完成，data.message成功渲染。

更新前/后：当data变化时，会触发beforeUpdate和updated方法。

销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

1、什么是vue生命周期

答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

2、vue生命周期的作用是什么

答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

3、第一次页面加载会触发哪几个钩子

答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

4、DOM 渲染在哪个周期中就已经完成

答：DOM 渲染在 mounted 中就已经完成了。

5、简单描述每个周期具体适合哪些场景

答：生命周期钩子的一些使用方法：

beforecreate : 可以在这加个loading事件，在加载实例时触发

created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用

mounted : 挂载元素，获取到DOM节点

updated : 如果对数据统一处理，在这里写上相应函数

beforeDestroy : 可以做一个确认停止事件的确认框

nextTick : 更新数据后立即操作dom


二十、说出至少4种vue当中的指令和它的用法？

v-if：判断是否隐藏；v-for：数据循环；v-bind:class：绑定一个属性；v-model：实现双向绑定


二十一、vue-loader是什么？使用它的用途有哪些？

解析.vue文件的一个加载器。（深入理解见https://www.jb51.net/article/115480.htm）
用途：js可以写es6、style样式可以scss或less、template可以加jade等

根据官网的定义，vue-loader 是 webpack 的一个 loader，用于处理 .vue 文件。
其次，使用vue-cli脚手架，作者已经配置好了基本的配置，开箱及用，你需要做的就是npm install 安装下依赖，然后就可以开发业务代码了。当然，如果你想进阶，最好熟悉下vue-loader的具体配置，而不要依赖脚手架


二十二、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？

答：css的预编译。（scss是sass的一个升级版本，完全兼容sass之前的功能，又有了些新增能力，最主要的就是sass是靠缩进表示嵌套关系，scss是花括号）
使用步骤：
第一步：先装css-loader、node-loader、sass-loader等加载器模块
第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss
第三步：在同一个文件，配置一个module属性
第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”

特性:

可以用变量，例如（$变量名称=值）；

可以用混合器，混入@mixin 可以传变量

可以嵌套

继承@extend 不可以传变量，相同样式直接继承，不会造成代码冗余；基类未被继承时，也会被编译成css代码


二十三、为什么使用key？

当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。

二十四、为什么避免 v-if 和 v-for 用在一起

当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。
通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。


扩展：

一、不应同时使用
v-for和v-if不应该一起使用。
原因：v-for比v-if优先，即每一次都需要遍历整个数组，影响速度。
例如重构项目的时候遇到的旧代码：

<div
  v-for="(fileMsg,index) in fileMsgList"
  :key="fileMsg.id"
  v-if="index < 2"
>
  <sys-file-layout :fileMsg="fileMsg"></sys-file-layout>
</div>

想要循环生成一系列组件块，但是不希望生成序号1之后的内容，同时用了v-if和v-for，
那么，还是会根据整个数组生成所有组件块，之后才判断v-if让多余的小时，非常耗资源。

二、解决
1、必要情况下应该替换成computed属性。

computed: {
  fileMsgListCom() {
    return this.fileMsgList.filter((item, index) => {
      return item < 2;
    });
  }
} 
<div                                                                  
  class="file_name"                                     
  v-for="(fileMsg,index) in fileMsgListCom"             
  :key="fileMsg.id"                                          
>                                                       
  <sys-file-layout :fileMsg="fileMsg"></sys-file-layout>
</div> 

2、把 v-if 改成 v-show。

如果此 v-for上层已经有 v-for循环了，此处只是取了上层循环对象中的一个数组继续作循环（其实这里项目遇到的就是这个问题），
我想不出方法使用computed计算属性如何计算（获取不到多层循环后的此数组内容）。
也可以 v-if 改成 v-show，可以共存。

<div
  class="file_name"
  v-for="(fileMsg,index) in file.documents"
  :key="fileMsg.id"
  v-show="index < 2"
>
  <sys-file-layout :fileMsg="fileMsg"></sys-file-layout>
</div>


二十五、VNode是什么？虚拟 DOM是什么？ 详情见 https://www.jb51.net/article/105221.htm

Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。



2018 vue前端面试题

1、active-class是哪个组件的属性？嵌套路由怎么定义？
答：vue-router模块的router-link组件。
嵌套路由顾名思义就是路由的多层嵌套。
一级路由里面使用children数组配置子路由，就是嵌套路由。

2、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？ 
答：在router目录下的index.js文件中，对path属性加上/:id。  使用router对象的params.id

4、scss是什么？安装使用的步骤是？有哪几大特性？
答：预处理css，把css当做函数编写，定义变量,嵌套。 
先装css-loader、node-loader、sass-loader等加载器模块，
在webpack-base.config.js配置文件中加多一个拓展:extenstion，再加多一个模块：module里面test、loader

5、mint-ui是什么？怎么使用？说出至少三个组件使用方法？ https://www.cnblogs.com/stella1024/p/7771334.html
答：基于vue的前端组件库。
npm安装，然后import样式和js，vue.use（mintUi）全局引入。
在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper
 

6、v-model是什么？怎么使用？ vue中标签怎么绑定事件？
答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。
vue的model层的data属性。绑定事件：<input @click=doLog() />
 

7、axios是什么？怎么使用？描述使用它实现登录功能的流程？
答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中

 Vue.js 1.0 我们常使用 vue-resource (官方ajax库), Vue 2.0 发布后作者宣告不再对 vue-resource 进行更新， 推荐我们使用 axios (基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用)

8、axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？

答：跨域，添加用户操作，更新操作。

9、什么是RESTful API？怎么使用?

答：是一个api的标准，无状态请求。请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete
 

10、vuex是什么？怎么使用？哪种功能场景使用它？

答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车
 
11、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？

答：一个model+view+viewModel框架，数据模型model，viewModel连接两个

区别：vue数据驱动，通过数据来显示视图层而不是节点操作。

场景：数据操作比较多的场景，更加便捷
 

12、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？

答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives

钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）

钩子函数参数：el、binding

14、vue-router是什么？它有哪些组件？

答：vue用来写路由一个插件。router-link、router-view
 

15、导航钩子有哪些？它们有哪些参数？

答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave

参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种
 

16、Vue的双向数据绑定原理是什么？

答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：

第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

ps：16题答案同样适合”vue data是怎么实现的？”此面试题。

18、请说下封装 vue 组件的过程？

答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。

然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。
 

19、你是怎么认识vuex的？

答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。
通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。

应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。
21、请说出vue.cli项目中src目录每个文件夹和文件的用法？

答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件
 

22、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？

答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default {

第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’

第三步：注入到vue的子组件的components属性上面,components:{smithButton}

第四步：在template视图view中使用，<smith-button>  </smith-button>
问题有：smithButton命名，使用的时候则smith-button。
 

23、聊聊你对Vue.js的template编译的理解？ https://www.jianshu.com/p/e1669afa30b8 

答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）

详情步骤：

首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 抽象语法树  即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。

然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）

挑战一下：
1、vue响应式原理？https://blog.csdn.net/GitChat/article/details/78516752   看这篇https://blog.csdn.net/aaa333qwe/article/details/80093810

 

有一个数据a.b,在vue对象实例化过程中，会给a,b通过ES5的defineProperty()方法，添加getter和setter方法，同时vue.js会对模板做编译，解析生成一个指令对象，比如v-text指令，每个指令对象都会关联一个watcher，当对指令对象求值时，就会触发getter，并将依赖收集到watcher中；当再次改变a.b值时，就会触发setter方法，会通知到对应关联的watcher,watcher则再次对a.b求值，计算对比新旧值，当值改变时，watcher会通知到指令，调用指令的update方法，由于指令是对dom的封装，所以会调用原生dom的方法，去更新视图。

2、vue-router实现原理？

https://www.cnblogs.com/yanze/p/7644631.html   https://segmentfault.com/a/1190000015123061

3、为什么要选vue？与其它框架对比的优势和劣势？

(1)vue.js更轻量，gzip后大小只有20K+,React gzip后大小为44k，Angular gzip后大小有56k，所以对于移动端来说，vue.js更适合； 
(2)vue.js**更易上手，学习曲线平稳，而Angular入门较难，概念较多(比如依赖注入)，它使用java写的**，很多思想沿用了后台的技术，react需学习较多东西，附带react全家桶， 
(3)吸收两家之长，借用了angular的指令(比如v-show,v-hide对应angular的ng-show,ng-hide)和react的组件化(将一个页面抽成一个组件，组件具有完整的生命周期) 
(4)vue还有自己的特点，比如计算属性

4、vue如何实现父子组件通信，以及非父子组件通信？

http://www.cnblogs.com/sichaoyun/p/6690322.html#4021894


5、vuejs与angularjs以及react的区别？
6、vuex是用来做什么的？
7、vue源码结构


 

组件的设计原则
(1)页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块) 
(2)每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中) 
(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑) 
(3)页面不过是组件的容器，组件可以嵌套自由组合成完整的页面

 

Virtual DOM算法，简单总结下包括几个步骤： https://www.cnblogs.com/aaronjs/p/7274965.html

用JS对象描述出DOM树的结构，然后在初始化构建中，用这个描述树去构建真正的DOM，并实际展现到页面中
当有数据状态变更时，重新构建一个新的JS的DOM树，通过新旧对比DOM数的变化diff，并记录两棵树差异
把步骤2中对应的差异通过步骤1重新构建真正的DOM，并重新渲染到页面中，这样整个虚拟DOM的操作就完成了，视图也就更新了


https://www.cnblogs.com/aimeeblogs/p/9501490.html



=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


问：Vue面试中，经常会被问到的面试题/Vue知识点整理

一、对于MVVM的理解？
二、Vue的生命周期
三、 Vue实现数据双向绑定的原理：Object.defineProperty（）
四、Vue组件间的参数传递
五、Vue的路由实现：hash模式 和 history模式
六、Vue与Angular以及React的区别？
七、vue路由的钩子函数（路由的导航守卫）
八、vuex是什么？怎么使用？哪种功能场景使用它？
九、vue-cli如何新增自定义指令？
十、vue如何自定义一个过滤器？
十一、对keep-alive 的了解？
十二、一句话就能回答的面试题



答：

一、对于MVVM的理解？

MVVM 是 Model-View-ViewModel 的缩写。
Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。
View 代表UI 组件，它负责将数据模型转化成UI 展现出来。
ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。
在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

二、Vue的生命周期

beforeCreate（创建前）
在数据观测和初始化事件还未开始

created（创建后） 
完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来

beforeMount（载入前） 
在挂载开始之前被调用，相关的render函数首次被调用。
实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。

mounted（载入后） 
在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。
实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。

beforeUpdate（更新前） 
在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。
可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。

updated（更新后） 
在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。
调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。
然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

beforeDestroy（销毁前） 
在实例销毁之前调用。实例仍然完全可用。

destroyed（销毁后） 
在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。


1.什么是vue生命周期？
答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。

2.vue生命周期的作用是什么？
答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

3.vue生命周期总共有几个阶段？
答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。

4.第一次页面加载会触发哪几个钩子？
答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。

5.DOM 渲染在 哪个周期中就已经完成？
答：DOM 渲染在 mounted 中就已经完成了

拓展：
beforeCreate, created 	这两个生命周期  	this.$el 为 undefined，没有dom节点，所以无法操作dom元素
beforeMount 							this.$el 为 <div id='root'></div> 还没有进行替换
mounted 								这个时候已经替换了，之后的生命周期跟这个一样

beforeCreate, created, beforeMount, mounted 这四个都是一次性的
组件只调用一次
另外，beforeMount, mounted在服务端渲染不会被调用，因为没有DOM节点

在 beforeMount, mounted 之间，把 vm.$el(虚拟dom)替换到根节点上


-----
另外 activated, deactivated 这两个生命周期与vue的原生组件 keep-alive有关


三、 Vue实现数据双向绑定的原理：Object.defineProperty（）


vue实现数据双向绑定主要是：采用  数据劫持  结合  发布者-订阅者模式  的方式，
通过Object.defineProperty（）来劫持各个属性的setter，getter，
在数据变动时发布消息给订阅者，触发相应监听回调。

当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，
Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。
用户看不到 getter/setter，
但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。


js实现简单的双向绑定

<body>
    <div id="app">
    <input type="text" id="txt">
    <p id="show"></p>
</div>
</body>
<script type="text/javascript">
    var obj = {}
    Object.defineProperty(obj, 'txt', {
        get: function () {
            return obj
        },
        set: function (newValue) {
            document.getElementById('txt').value = newValue
            document.getElementById('show').innerHTML = newValue
        }
    })
    document.addEventListener('keyup', function (e) {
        obj.txt = e.target.value

    })
    //这里添加监听事件有点问题，添加到了DOM上，任何地方按下键盘都会触发
</script>

    document.getElementById('txt').addEventListener('keyup', function (e) {
        obj.txt = e.target.value
    })
    //应该改成此input的监听事件


四、Vue组件间的参数传递


1.父组件与子组件传值
父组件传给子组件：子组件通过props方法接受数据;
子组件传给父组件：$emit方法传递参数

2.非父子组件间的数据传递，兄弟组件传值
eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。
项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）

-----

父子组件之间用 $emit
兄弟组件之间用 vuex （上面的eventBus没用过，不太了解）
跨层级组件之间 用 provide 和 inject


五、Vue的路由实现：hash模式 和 history模式

hash模式：
在浏览器中符号“#”，
#以及#后面的字符称之为hash，用window.location.hash读取；

特点：hash虽然在URL中，但不被包括在HTTP请求中；
用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。

hash 模式下，仅 hash 符号之前的内容会被包含在请求中，
如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。

-----

history模式：
history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）
可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。

history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，
如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。

Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……
所以呢，你要在服务端增加一个覆盖所有情况的候选资源：
如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”


扩展：

这个可以在 Router.js中的mode参数进行配置

export default () => {
	return new Router({
		routes,
		mode: 'history'
	})
}


六、Vue与Angular以及React的区别？

（版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟）
1.与AngularJS的区别
相同点：
都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。

不同点：
AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。

2.与React的区别
相同点：
React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。
不同点：
React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。


-----
这里不是太了解，没学过Angular以及React


七、vue路由的钩子函数（路由的导航守卫）

首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。

beforeEach主要有3个参数to，from，next：

to：route即将进入的目标路由对象，

from：route当前导航正要离开的路由

next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。


-----

全局钩子

router.beforeEach
router.beforeResolve
router.afterEach

路由配置钩子(路由独享的守卫)

beforeEnter

组件中的钩子(组件内的守卫)

beforeRouteEnter
beforeRouteUpdate
beforeRouteLeave



八、vuex是什么？怎么使用？哪种功能场景使用它？

只用来读取的状态集中放在store中； 
改变状态的方式是提交mutations，这是个同步的事物； 
异步逻辑应该封装在action中。


state
Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。
放的数据状态，不可以直接修改里面的数据。

getters
类似vue的计算属性，主要用来过滤一些数据。

mutations
mutations定义的方法动态修改Vuex 的 store 中的状态或数据。

action 
actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。
view 层通过 store.dispath 来分发 action。

modules
项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。


九、vue-cli如何新增自定义指令？

1.创建局部指令

var app = new Vue({
    el: '#app',
    data: {    
    },
    // 创建指令(可以多个)
    directives: {
        // 指令名称
        dir1: {
            inserted(el) {
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            }
        }
    }
})

2.全局指令

Vue.directive('dir2', {
    inserted(el) {
        console.log(el);
    }
})
3.指令的使用

<div id="app">
    <div v-dir1></div>
    <div v-dir2></div>
</div>


十、vue如何自定义一个过滤器？

html代码：
<div id="app">
     <input type="text" v-model="msg" />
     {{msg| capitalize }}
</div>

JS代码：
var vm=new Vue({
    el:"#app",
    data:{
        msg:''
    },
    filters: {
      capitalize: function (value) {
        if (!value) return ''
        value = value.toString()
        return value.charAt(0).toUpperCase() + value.slice(1)
      }
    }
})

全局定义过滤器

Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

过滤器接收表达式的值 (msg) 作为第一个参数。capitalize 过滤器将会收到 msg的值作为第一个参数。


十一、对keep-alive 的了解？

keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。

使用方法

<keep-alive include='include_components' exclude='exclude_components'>
  <component>
    <!-- 该组件是否缓存取决于include和exclude属性 -->
  </component>
</keep-alive>


参数解释
include - 字符串或正则表达式，只有名称匹配的组件会被缓存
exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存
include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。

使用示例


<!-- 逗号分隔字符串，只有组件a与b被缓存。 -->
<keep-alive include="a,b">
  <component></component>
</keep-alive>

<!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) -->
<keep-alive :include="/a|b/">
  <component></component>
</keep-alive>

<!-- Array (需要使用 v-bind，被包含的都会被缓存) -->
<keep-alive :include="['a', 'b']">
  <component></component>
</keep-alive>


十二、一句话就能回答的面试题

1.css只在当前组件起作用
答：在style标签中写入scoped即可 例如：<style scoped></style>

2.v-if 和 v-show 区别
答：v-if按照条件是否渲染，v-show是display的block或none；

3.$route和$router的区别
答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

4.vue.js的两个核心是什么？
答：数据驱动、组件系统

5.vue几种常用的指令
答：v-for 、 v-if 、v-bind、v-on、v-show、v-else

6.vue常用的修饰符？
答：
.prevent: 提交事件不再重载页面；
.stop: 阻止单击事件冒泡；
.self: 当事件发生在该元素本身而不是子元素的时候会触发；
.capture: 事件侦听，事件发生的时候会调用
.trim
.lazy
.number

7.v-on 可以绑定多个方法吗？
答：可以

8.vue中 key 值的作用？
答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。
如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序,而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。
key的作用主要是为了高效的更新虚拟DOM。

9.什么是vue的计算属性？
答：在模板中放入太多的逻辑会让模板过重且难以维护，
在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。
好处：
①使得数据处理结构清晰；
②依赖于数据，数据更新，处理结果自动更新；
③计算属性内部this指向vm实例；
④在template调用时，直接写计算属性名即可；
⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；
⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。

10.vue等单页面应用及其优缺点
答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，
核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；
第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。

11.怎么定义 vue-router 的动态路由? 怎么获取传过来的值
答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。


https://segmentfault.com/a/1190000016344599








=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


<router-view></router-view>
标签其实就是组件的引用
只不过再加入了vue-router之后,有了路由的概念
<组件名></组件名>这种使用组件的方式改成了
<router-view></router-view>

当有多个<router-view>的时候，就要使用命名

<router-view name='aaa'></router-view>

routes.js里的path配置也要修改
{
	path: '/app'
	components: { 	    	//component 变成 components
		default: Todo
		aaa: Login
	}
}

-----

<router-link></router-link>
这个其实就是 a 标签(页面HTML代码就是 a 标签)
<router-link to='/app'>app</router-link>
<a href='/app'>app</a>
只不过 a 标签默认是后台跳转
而<router-link>标签使它变成前台Javascript的 a 标签


-----
扩展：

<router-view>和<router-link>的配合使用



开发的时候有时候会遇到一种情况，
比如 ：点击这个链接跳转到其他组件的情况，通常会跳转到新的页面，
但是，我们不想跳转到新页面，只在当前页面切换着显示，
那么就要涉及到路由的嵌套了，也可以说是子路由的使用


在同个页面，切换显示不同组件的相应内容，同时地址栏的地址是会变的



navbar.vue：

<template>
	<div class="navbar">
		<ul id="main">
			<li><router-link  to="/food" >商品</router-link></li>
			<li><router-link  to="/rating">评价</router-link></li>
			<li><router-link  to="/seller">商家</router-link></li>
 
		</ul>
		
        <!-- 路由匹配到的组件将显示在这里 -->
       	<router-view></router-view>
</template>

https://blog.csdn.net/luoyu6/article/details/80098145




=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

问：插槽 slot

-----

答：

插槽使用场景是；如果子组件需要显示的内容并非来自本身，而是父组件传递进来的。
这个时候就要使用插槽

有三种插槽
1.默认插槽
2.具名插槽
3.作用域插槽 	<slot-scope><slot-scope>


1.
在组件中直接写html代码是没有用的，必须使用slot标签
<div id="app">
        <me-component>
            <h1>我是header</h1>   		//组件中如果没有slot，这个不会生效
        </me-component>
    </div>
<script >
    Vue.component('me-component', {         
        template:
                `<div>
                    <p>你好</p>
                    <slot></slot>  		//如果没有这个slot标签，那么组件中的 <h1>我是header</h1>   则不会显示
                </div>`
    })
    var vm = new Vue({
        el:"#app"
    })
</script >

//这种情况是只有一个slot，默认匹配的情况


2.
当有多个slot标签，则需要使用具名插槽

<div id="app">
    <me-component>
        <h1 slot="header">我是header</h1>  
        <h1 slot="footer">我是footerr</h1>
    </me-component>
</div>

<script>
Vue.component('me-component', {         
    template:
        `<div>
            <p>你好</p>
            {{text}}
            <slot name="header"></slot> 
            <slot name="footer"></slot> 
        </div>`
    data () {
    	return {
    		text: 儿子
    	}
    }
})
var vm = new Vue({
    el:"#app"
    data () {
    	return {
    		text: 父亲
    	}
    }
})
</script>


3.作用域插槽，<slot-scoped><slot-scoped>

一般来说：<me-component>{{text}}</me-component>
这里的text用的是 new vue 里的text，（父亲）
但是用到时候，希望使用组件中text属性，
这个时候，就需要用到作用域插槽


<me-component>
    <h1 slot="header">我是header</h1>  
    <h1 slot="footer">我是footerr</h1>
    <slot-scope='props'>
    	{{text}}   					//父亲
    	{{props.text}}				//儿子
    </slot-scope='props'>
</me-component>



=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

问：组件之间的传值

-----

答：
父子组件之间用 $emit
兄弟组件之间用 vuex
跨层级组件之间 用 provide 和 inject

provide 和 inject


爷爷组件的 provide 要写成方法返回的形式

provide () {
	return {
		yeye: this,
		value: this.value
	}
}
//这时因为在 provide 初始化的时候，vue对象这时还没有真正的初始化成功，
如果需要进行一些跟对象上挂钩的值的传递的话，需要提供一个function
不然直接 provide: {
	yeye: this,  			undefined
	value: this.value 		报错，因为 this都是 undefined，value就更没有了
}


inject['yeye','value']

//还有需要注意的就是，默认情况下
provide不提供 vue 的 reactive属性，也就是说，value只有第一次提供的值，
以后不管如何变化，孙子组件都不变


-----
扩展：

provide 和 inject

这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，
不论组件层次有多深，并在起上下游关系成立的时间里始终生效。
provide 和 inject 绑定并不是可响应的。这是刻意为之的。
然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。


第二种方式(传递返回对象的函数, 使用对象接收)


provide() {
  return {
    // 2.6.0 版本之前 通常传递this. 但这样的话 会传递很多用不到的属性
    theme: {
      color: 'xxx' //如果传入可响应的数据,这里的属性还是可响应的
    }
  };
}
inject: {
  //这里可以换成其它名字
  theme: {
    from: "theme", // 数据来源
    default: () => ({}) //降级情况下使用的 value
    //可以是 普通值
    //可以是 对非原始值使用一个工厂方法
  }
}
//正常子组件
this.theme //即可访问
//子组件是函数式组件的使用方式
injections.theme.color

-----

Vue.observable( object )
让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。
可以作为最小化的跨组件状态存储器，用于简单的场景

提供数据可改为

provide() {
  //这时提供的theme 则为可响应的数据
  this.theme = Vue.observable({
    color: "blue"
  });
  return {
    theme: this.theme
  };
},
————————————————
版权声明：本文为CSDN博主「请叫我萝卜斯基先生」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/luobosiji/article/details/90696103




=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

1.如果是没有赋默认初始值，vue的数据不是响应式，两种解决方式：1.赋默认初始值，2.使用$set将数据变成响应式的。
2.有默认初始值（这种情况一般为改动数组下标的方式或者为改动数组长度）
vue官方规定这两种方式无效。

var vm = new Vue({
  data: {
    items: ['a', 'b', 'c']
  }
})
vm.items[1] = 'x' // 不是响应性的
vm.items.length = 2 // 不是响应性的


1.解决方法：
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)

你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：
vm.$set(vm.items, indexOfItem, newValue)

2.解决方法：
vm.items.splice(newLength)

https://www.jianshu.com/p/de1ef42de367


=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

ES6新特性


一、const 与 let 变量

var 在函数中会有变量提升

function getClothing(isCold) {
  if (isCold) {
    var freezing = 'Grab a jacket!';
  } else {
    var hot = "It's a shorts kind of day.";
    console.log(freezing);
  }
}
getClothing(false)
//这个时候输出的是undefined
//按理来说在else中，没有var freezing ，应该会报错 freezing is not defined
//但是实际上 却是 undefined，这表明已经执行了 var freezing，但是还没有赋值
//这是因为执行function函数之前,所有变量都会被提升, 提升到函数作用域顶部.
//也就是说，函数里的变量声明，不管在函数体哪里，都会放到函数的直接下级，进行声明
//这也就是 var 的变量提升


let与const声明的变量解决了这种问题,因为他们是块级作用域, 
在代码块(用{}表示)中使用let或const声明变量, 该变量会陷入暂时性死区直到该变量的声明被处理.

function getClothing(isCold) {
  if (isCold) {
    const freezing = 'Grab a jacket!';
  } else {
    const hot = 'It's a shorts kind of day.';
    console.log(freezing);
  }
}
运行getClothing(false)后输出的是ReferenceError: freezing is not defined,
因为 freezing 没有在 else 语句、函数作用域或全局作用域内声明，所以抛出 ReferenceError。


var 可以重复声明，只有最后一个有效
使用let声明的变量可以重新赋值,但是不能在同一作用域内重新声明
使用const声明的变量必须赋值初始化,但是不能在同一作用域类重新声明也无法重新赋值.
如果const是对象，那么可以对const的属性进行修改



二、模板字面量（字符串模板）


在ES6之前,将字符串连接到一起的方法是+或者concat()方法,如

const student = {
  name: 'Richard Kalehoff',
  guardian: 'Mr. Kalehoff'
};

const teacher = {
  name: 'Mrs. Wilson',
  room: 'N231'
}

let message = student.name + ' please see ' + teacher.name + ' in ' + teacher.room + ' to pick up your report card.';
模板字面量本质上是包含嵌入式表达式的字符串字面量.
模板字面量用倒引号 ( `` )（而不是单引号 ( '' ) 或双引号( "" )）表示，可以包含用 ${expression} 表示的占位符

let message = `${student.name} please see ${teacher.name} in ${teacher.room} to pick up your report card.`;



三、解构



在ES6中,可以使用解构从数组和对象提取值并赋值给独特的变量

解构数组的值:

const point = [10, 25, -34];
const [x, y, z] = point;
console.log(x, y, z);
Prints: 10 25 -34

[]表示被解构的数组, x,y,z表示要将数组中的值存储在其中的变量, 在解构数组是, 还可以忽略值, 例如const[x,,z]=point,忽略y坐标.

解构对象中的值:

const gemstone = {
  type: 'quartz',
  color: 'rose',
  karat: 21.29
};
const {type, color, karat} = gemstone;
console.log(type, color, karat);

花括号 { } 表示被解构的对象，type、color 和 karat 表示要将对象中的属性存储到其中的变量


//对象的解构必须名称和对象中的key一致。
//数组则随便起名
//个人理解，解构其实就是在当前作用域let 几个变量，把要结构的对象中的值赋值给这些变量
//记住，这个是当前作用域，如果是window，则都可以用，如果是函数内，则只能在函数作用域中生效



四、对象字面量简写法


一般初始化对象的写法为：

let type = 'quartz';
let color = 'rose';
let carat = 21.29;

const gemstone = {
  type: type,
  color: color,
  carat: carat
};

console.log(gemstone);

-------
使用ES6的话，使用和所分配的变量名称相同的名称初始化对象时，
如果属性名称和所分配的变量名称一样，那么就可以从对象属性中删掉这些重复的变量名称。

let type = 'quartz';
let color = 'rose';
let carat = 21.29;
const gemstone = {type,color,carat};
console.log(gemstone);



简写方法的名称:

const gemstone = {
  type,
  color,
  carat,
  calculateWorth: function() {
    // 将根据类型(type)，颜色(color)和克拉(carat)计算宝石(gemstone)的价值
  }
};
匿名函数被分配给属性 calculateWorth，但是真的需要 function 关键字吗？在 ES6 中不需要！

let gemstone = {
  type,
  color,
  carat,
  calculateWorth() { ... }
};

这样可以省略不写function



五、for...of循环



for...of循环是最新添加到 JavaScript 循环系列中的循环。
它结合了其兄弟循环形式 for 循环和 for...in 循环的优势，
可以循环任何可迭代（也就是遵守可迭代协议）类型的数据。
默认情况下，包含以下数据类型：String、Array、Map 和 Set，
注意不包含 Object 数据类型（即 {}）。默认情况下，对象不可迭代。




for循环

const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for (let i = 0; i < digits.length; i++) {
  console.log(digits[i]);
}

for 循环的最大缺点是需要跟踪计数器和退出条件。
虽然 for 循环在循环数组时的确具有优势，但是某些数据结构不是数组，因此并非始终适合使用 loop 循环。




for...in循环

const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

for (const index in digits) {
  console.log(digits[index]);
}

依然需要使用 index 来访问数组的值
当你需要向数组中添加额外的方法（或另一个对象）时，for...in 循环会带来很大的麻烦。
因为 for...in 循环循环访问所有可枚举的属性，意味着如果向数组的原型中添加任何其他属性，这些属性也会出现在循环中。

Array.prototype.decimalfy = function() { 			
  for (let i = 0; i < this.length; i++) {
    this[i] = this[i].toFixed(2);
  }
};

const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

for (const index in digits) {
  console.log(digits[index]);
}

//上面的意思就是 本来循环输出的本意是， 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
//但是因为给Array.prototype 添加了一个方法，这个方法也会被遍历出来（Array.prototype 默认是一个空数组 []）
//Array的一些其他方法是 Object 继承下来的（至于为什么不被循环，查一下是不是和可枚举有关）
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9，f 
上面的f 就是 Array.prototype.decimalfy 这个方法




forEach 循环 是另一种形式的 JavaScript 循环。但是，forEach() 实际上是数组方法，因此只能用在数组中。也无法停止或退出 forEach 循环。如果希望你的循环中出现这种行为，则需要使用基本的 for 循环。


//查一下for循环的面试题，了解各种循环

for...of循环
for...of 循环用于循环访问任何可迭代的数据类型。
for...of 循环的编写方式和 for...in 循环的基本一样，只是将 in 替换为 of，可以忽略索引。

const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

for (const digit of digits) {
  console.log(digit);
}

建议使用复数对象名称来表示多个值的集合。
这样，循环该集合时，可以使用名称的单数版本来表示集合中的单个值。例如，for (const button of buttons) {…}。

for...of 循环还具有其他优势，解决了 for 和 for...in 循环的不足之处。你可以随时停止或退出 for...of 循环。

for (const digit of digits) {
  if (digit % 2 === 0) {
    continue;
  }
  console.log(digit);
}
不用担心向对象中添加新的属性。for...of 循环将只循环访问对象中的值。

Array.prototype.decimalfy = function() {
  for (i = 0; i < this.length; i++) {
    this[i] = this[i].toFixed(2);
  }
};

const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

for (const digit of digits) {
  console.log(digit);
}




六、展开运算符


展开运算符（用三个连续的点 (...) 表示）是 ES6 中的新概念，使你能够将字面量对象展开为多个元素

const books = ["Don Quixote", "The Hobbit", "Alice in Wonderland", "Tale of Two Cities"];
console.log(...books);
Prints: Don Quixote The Hobbit Alice in Wonderland Tale of Two Cities

展开运算符的一个用途是结合数组。

如果你需要结合多个数组，在有展开运算符之前，必须使用 Array的 concat() 方法。

const fruits = ["apples", "bananas", "pears"];
const vegetables = ["corn", "potatoes", "carrots"];
const produce = fruits.concat(vegetables);
console.log(produce);
Prints: ["apples", "bananas", "pears", "corn", "potatoes", "carrots"]

使用展开符来结合数组

const fruits = ["apples", "bananas", "pears"];
const vegetables = ["corn", "potatoes", "carrots"];
const produce = [...fruits,...vegetables];
console.log(produce);

问： ... 展开运算符不能展开对象吗？



七、剩余参数(可变参数)


使用展开运算符将数组展开为多个元素, 使用剩余参数可以将多个元素绑定到一个数组中.
剩余参数也用三个连续的点 ( ... ) 表示，使你能够将不定数量的元素表示为数组.

用途1: 将变量赋数组值时:

const order = [20.17, 18.67, 1.50, "cheese", "eggs", "milk", "bread"];
const [total, subtotal, tax, ...items] = order;
console.log(total, subtotal, tax, items);


//这个感觉有点模糊

用途2: 可变参数函数
对于参数不固定的函数,ES6之前是使用参数对象(arguments)处理:



function sum() {
  let total = 0;  
  for(const argument of arguments) {
    total += argument;
  }
  return total;
}
在ES6中使用剩余参数运算符则更为简洁,可读性提高:

function sum(...nums) {
  let total = 0;  
  for(const num of nums) {
    total += num;
  }
  return total;
}

//这个感觉有点模糊




八、ES6箭头函数


ES6之前,使用普通函数把其中每个名字转换为大写形式：

const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(function(name) { 
  return name.toUpperCase();
});
箭头函数表示:

const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
  name => name.toUpperCase()
);

普通函数可以是  函数声明  或者  函数表达式  , 
但是箭头函数始终都是  表达式  , 全程是箭头函数表达式, 因此因此仅在表达式有效时才能使用，包括：

存储在变量中，
当做参数传递给函数，
存储在对象的属性中。

const greet = name => `Hello ${name}!`;
可以如下调用:

greet('Asser');


如果函数的参数只有一个,不需要使用()包起来,但是  如果没有参数  或者  多个参数, 则必须需要将参数列表放在圆括号内:

// 空参数列表需要括号
const sayHi = () => console.log('Hello Udacity Student!');

// 多个参数需要括号
const orderIceCream = (flavor, cone) => console.log(`Here's your ${flavor} ice cream in a ${cone} cone.`);
orderIceCream('chocolate', 'waffle');


一般箭头函数都只有一个表达式作为函数主题:

const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
  name => name.toUpperCase() 			//这里面只有一句语句
);
这种函数表达式形式称为简写主体语法:

1.在函数主体周围没有花括号,
2.自动返回表达式


但是如果箭头函数的主体内需要多行代码, 则需要使用常规主体语法:

1.它将函数主体放在花括号内
2.需要使用 return 语句来返回内容。

const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map( name => {
  name = name.toUpperCase();
  return `${name} has ${name.length} characters in their name`;
});




九、javascript标准函数this


new 对象
const mySundae = new Sundae('Chocolate', ['Sprinkles', 'Hot Fudge']);
sundae这个构造函数内的this的值是实例对象, 因为他使用new被调用.

指定的对象
const result = obj1.printName.call(obj2);
函数使用call/apply被调用,this的值指向指定的obj2,因为call()第一个参数明确设置this的指向

上下文对象
data.teleport();
函数是对象的方法, this指向就是那个对象,此处this就是指向data.

全局对象或 undefined
teleport();
此处是this指向全局对象,在严格模式下,指向undefined.


关于更多的this讲解:
https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/ch2.md



箭头函数和this
对于普通函数, this的值    基于函数如何被调用  ,
 对于箭头函数,this的值基于函数周围的上下文, 换句话说,this的值和函数外面的this的值是一样的.


function IceCream() {
    this.scoops = 0;
}

// 为 IceCream 添加 addScoop 方法
IceCream.prototype.addScoop = function() {
    setTimeout(function() {
        this.scoops++;
        console.log('scoop added!');
        console.log(this.scoops); // undefined+1=NaN
        console.log(dessert.scoops); //0
    }, 500);
};


const dessert = new IceCream();
dessert.addScoop();



传递给 setTimeout() 的函数被调用时没用到   new  、call() 或 apply()，
也没用到  上下文对象  。
意味着函数内的 this 的值是全局对象，不是 dessert 对象。
实际上发生的情况是，创建了新的 scoops 变量（默认值为 undefined），然后递增（undefined + 1 结果为 NaN）;

-------

解决此问题的方式之一是使用闭包(closure):（下面的用法是闭包？查一下，可能我对闭包不够了解）

// 构造函数
function IceCream() {
  this.scoops = 0;
}

// 为 IceCream 添加 addScoop 方法
IceCream.prototype.addScoop = function() {
  const cone = this; // 设置 `this` 给 `cone`变量
  setTimeout(function() {
    cone.scoops++; // 引用`cone`变量
    console.log('scoop added!'); 
    console.log(dessert.scoops);//1
  }, 0.5);
};

const dessert = new IceCream();
dessert.addScoop();



箭头函数的作用正是如此, 将setTimeOut()的函数改为剪头函数:

// 构造函数
function IceCream() {
  this.scoops = 0;
}

// 为 IceCream 添加 addScoop 方法
IceCream.prototype.addScoop = function() {
  setTimeout(() => { // 一个箭头函数被传递给setTimeout
    this.scoops++;
    console.log('scoop added!');
    console.log(dessert.scoops);//1
  }, 0.5);
};

const dessert = new IceCream();
dessert.addScoop();

（这里没有说的太清晰，再看看其它的资料）




十、默认参数函数



function greet(name, greeting) {
  name = (typeof name !== 'undefined') ?  name : 'Student';
  greeting = (typeof greeting !== 'undefined') ?  greeting : 'Welcome';

  return `${greeting} ${name}!`;
}

greet(); // Welcome Student!
greet('James'); // Welcome James!
greet('Richard', 'Howdy'); // Howdy Richard!
greet() 函数中混乱的前两行的作用是什么？它们的作用是当所需的参数未提供时，为函数提供默认的值。但是看起来很麻烦, ES6引入一种新的方式创建默认值, 他叫默认函数参数:

function greet(name = 'Student', greeting = 'Welcome') {
  return `${greeting} ${name}!`;
}

greet(); // Welcome Student!
greet('James'); // Welcome James!
greet('Richard', 'Howdy'); // Howdy Richard!






十一、默认值与解构


默认值与解构数组

function createGrid([width = 5, height = 5]) {
  return `Generates a ${width} x ${height} grid`;
}

createGrid([]); // Generates a 5 x 5 grid
createGrid([2]); // Generates a 2 x 5 grid
createGrid([2, 3]); // Generates a 2 x 3 grid
createGrid([undefined, 3]); // Generates a 5 x 3 grid
createGrid() 函数预期传入的是数组。它通过解构将数组中的第一项设为 width，第二项设为 height。如果数组为空，或者只有一项，那么就会使用默认参数，并将缺失的参数设为默认值 5。

但是存在一个问题:

createGrid(); // throws an error
Uncaught TypeError: Cannot read property 'Symbol(Symbol.iterator)' of undefined

出现错误，因为 createGrid() 预期传入的是数组，然后对其进行解构。因为函数被调用时没有传入数组，所以出现问题。但是，我们可以使用默认的函数参数！

function createGrid([width = 5, height = 5] = []) {
  return `Generating a grid of ${width} by ${height}`;
}
createGrid(); // Generates a 5 x 5 grid

Returns: Generates a 5 x 5 grid



默认值与解构函数
就像使用数组默认值解构数组一样，函数可以让对象成为一个默认参数，并使用对象解构：

function createSundae({scoops = 1, toppings = ['Hot Fudge']}={}) {
  const scoopText = scoops === 1 ? 'scoop' : 'scoops';
  return `Your sundae has ${scoops} ${scoopText} with ${toppings.join(' and ')} toppings.`;
}

createSundae({}); // Your sundae has 1 scoop with Hot Fudge toppings.
createSundae({scoops: 2}); // Your sundae has 2 scoops with Hot Fudge toppings.
createSundae({scoops: 2, toppings: ['Sprinkles']}); // Your sundae has 2 scoops with Sprinkles toppings.
createSundae({toppings: ['Cookie Dough']}); // Your sundae has 1 scoop with Cookie Dough toppings.
createSundae(); // Your sundae has 1 scoop with Hot Fudge toppings.


数组默认值与对象默认值
默认函数参数只是个简单的添加内容，但是却带来很多便利！与数组默认值相比，对象默认值具备的一个优势是能够处理跳过的选项。看看下面的代码：

function createSundae({scoops = 1, toppings = ['Hot Fudge']} = {}) { … }
在 createSundae() 函数使用对象默认值进行解构时，如果你想使用 scoops 的默认值，但是更改 toppings，那么只需使用 toppings 传入一个对象：

createSundae({toppings: ['Hot Fudge', 'Sprinkles', 'Caramel']});
将上述示例与使用数组默认值进行解构的同一函数相对比。

function createSundae([scoops = 1, toppings = ['Hot Fudge']] = []) { … }
对于这个函数，如果想使用 scoops 的默认数量，但是更改 toppings，则必须以这种奇怪的方式调用你的函数：

createSundae([undefined, ['Hot Fudge', 'Sprinkles', 'Caramel']]);
因为数组是基于位置的，我们需要传入 undefined 以跳过第一个参数（并使用默认值）来到达第二个参数。


十二、Javascript类
ES5创建类:

function Plane(numEngines) {
  this.numEngines = numEngines;
  this.enginesActive = false;
}

// 由所有实例 "继承" 的方法
Plane.prototype.startEngines = function () {
  console.log('starting engines...');
  this.enginesActive = true;
};
ES6类只是一个语法糖,原型继续实际上在底层隐藏起来, 与传统类机制语言有些区别.

class Plane {
  //constructor方法虽然在类中,但不是原型上的方法,只是用来生成实例的.
  constructor(numEngines) {
    this.numEngines = numEngines;
    this.enginesActive = false;
  }
  //原型上的方法, 由所有实例对象共享.
  startEngines() {
    console.log('starting engines…');
    this.enginesActive = true;
  }
}

console.log(typeof Plane); //function
javascript中类其实只是function, 方法之间不能使用 ,(逗号) ,不用逗号区分属性和方法.(但是可以使用分号  ;)



------

静态方法
要添加静态方法，请在方法名称前面加上关键字 static

class Plane {
  constructor(numEngines) {
    this.numEngines = numEngines;
    this.enginesActive = false;
  }
  static badWeather(planes) {
    for (plane of planes) {
      plane.enginesActive = false;
    }
  }
  startEngines() {
    console.log('starting engines…');
    this.enginesActive = true;
  }
}


1.关键字class带来其他基于类的语言的很多思想,但是没有向javascript中添加此功能
2.javascript类实际上还是原型继承
3.创建javascript类的新实例时必须使用new关键字



-----


super 和 extends
使用新的super和extends关键字扩展类:

class Tree {
  constructor(size = '10', leaves = {spring: 'green', summer: 'green', fall: 'orange', winter: null}) {
    this.size = size;
    this.leaves = leaves;
    this.leafColor = null;
  }

  changeSeason(season) {
    this.leafColor = this.leaves[season];
    if (season === 'spring') {
      this.size += 1;
    }
  }
}

class Maple extends Tree {
  constructor(syrupQty = 15, size, leaves) {
    super(size, leaves); //super用作函数
    this.syrupQty = syrupQty;
  }

  changeSeason(season) {
    super.changeSeason(season);//super用作对象
    if (season === 'spring') {
      this.syrupQty += 1;
    }
  }

  gatherSyrup() {
    this.syrupQty -= 3;
  }
}


使用ES5编写同样功能的类:


function Tree(size, leaves) {
  this.size = size || 10;
  this.leaves = leaves || {spring: 'green', summer: 'green', fall: 'orange', winter: null};
  this.leafColor;
}

Tree.prototype.changeSeason = function(season) {
  this.leafColor = this.leaves[season];
  if (season === 'spring') {
    this.size += 1;
  }
}

function Maple (syrupQty, size, leaves) {
  Tree.call(this, size, leaves);
  this.syrupQty = syrupQty || 15;
}

Maple.prototype = Object.create(Tree.prototype);
Maple.prototype.constructor = Maple;

Maple.prototype.changeSeason = function(season) {
  Tree.prototype.changeSeason.call(this, season);
  if (season === 'spring') {
    this.syrupQty += 1;
  }
}

Maple.prototype.gatherSyrup = function() {
  this.syrupQty -= 3;
}


super 必须在 this 之前被调用（这个为什么？）

class Apple {}
class GrannySmith extends Apple {
  constructor(tartnessLevel, energy) {
    this.tartnessLevel = tartnessLevel; // 在 'super' 之前会抛出一个错误！
    super(energy); 
  }
}


十三、



=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


问题：继承（原型继承）

----------------------------------

答： 

原型继承

//定义一个 Animal 构造函数，作为 Dog 的父类
function Animal () {
    this.superType = 'Animal';
}

Animal.prototype.superSpeak = function () {
    alert(this.superType);
}

function Dog (name) {
    this.name = name;
    this.type = 'Dog';  
}
//改变Dog的prototype指针，指向一个 Animal 实例
Dog.prototype = new Animal();
//上面那行就相当于这么写
//var animal = new Animal();
//Dog.prototype = animal;

Dog.prototype.speak = function () {
　　alert(this.type);
}
var doggie = new Dog('jiwawa');
doggie.superSpeak();  //Animal 



这就说明，我们可以通过原型链的方式，实现 Dog 继承 Animal 的所有属性和方法。

总结来说：就是当重写了Dog.prototype指向的原型对象后，实例的内部指针也发生了改变，指向了新的原型对象，然后就能实现类与类之间的继承了。
（但是如果在重写原型对象之前，产生的实例，其内部指针指向的还是最初的原型对象。这个我下次再发篇文章讲。



-----


function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}


function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}


// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: '小明',
    grade: 2
});
xiaoming.name; // '小明'
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true



小结
JavaScript的原型继承实现方式就是：

定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；

借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；

继续在新的构造函数的原型上定义新方法。

-------

https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072


以上代码可以引出几个问题：

利用空F函数那一段代码中，修复PrimaryStudent.prototype.constructor = PrimaryStudent有什么意义吗？

为什么要用过桥函数F呢，我看有书上是 直接PrimaryStudent.prototype = new Student()的

其实我觉得除了上文廖老师所讲的借助中间函数F的方法实现原型链继承，还可以通过：

PrimaryStudent.prototype = Object.create(Student.prototype)
这种一样可以实现原型链继承（已实验），而且感觉比中间函数F方法要简单点。 当然看到下面评论也有说用proto的，但直接用proto应该是不太好的。

好吧事实上有四种原型继承的方法，并且各有优缺点



----------------------------------

继承（class继承）



class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert('Hello, ' + this.name + '!');
    }
}

比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），
这样就避免了Student.prototype.hello = function () {...}这样分散的代码。


class继承
用class定义对象的另一个巨大的好处是继承更方便了。
想一想我们从Student派生一个PrimaryStudent需要编写的代码量。
现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：

class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}




=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================


问题：语法糖

----------------------------------

答： 


之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，糖在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。

之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：
代码更简洁流畅，代码更语义自然...
写得爽，看着爽，就像吃了糖。效率高，错误少，老公回家早... 

PS: 据说还有一种叫做「语法盐」的东西，主要目的是通过反人类的语法，让你更痛苦的写代码。其实它同样能达到避免代码书写错误的效果，但编程效率应该是降低了，毕竟提高了语法学习门槛，让人咸到忧伤... 

我觉着 js 里的对象原型继承有点「咸」，不然 ES6 也不会急着加糖（纯吐槽）

----------

最基本的，for循环就是一个语法糖：
for (var i = 0; i < 5; i++){
    ... 
}

而这个实际上跟while没啥区别：

var i=0;
while (i < 5){
    ...
    i++;
}

简单说，语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。


----

简单的说，语法糖就是一种便捷写法。例如：input.map(item => item + 1);他表示的意思是input.map(function (item) {
  return item + 1;
});

通过例子你可以看出来，语法糖的使用其实就是让我们的写的代码更简单，看起来也更容易理解。

作者：知乎用户
链接：https://www.zhihu.com/question/20651624/answer/87484835
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

问题：new操作符干了些什么

----------------------------------

答： new一个对象有四个过程：

1、创建一个空对象

var obj = new Object(); 

2、让Person中的this指向obj，并执行Person的函数体

var result = Person.call(obj);  

3、设置原型链，将obj的__proto__成员指向了Person函数对象的prototype成员对象

obj.__proto__ = Person.prototype; 

4、判断Person的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。

if (typeof(result) == "object") 
	person = result;  
else
	person = obj；


=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

问题：call() apply() bind()

----------------------------------

答： 

在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。
在说区别之前还是先总结一下三者的相似之处：
1、都是用来改变函数的this对象的指向的。
2、第一个参数都是this要指向的对象。
3、都可以利用后续参数传参。



var xw = {
    name : "小王",
    gender : "男",
    age : 24,
    say : function() {
        alert(this.name + " , " + this.gender + " ,今年" + this.age);                                
    }
	say1 : function(school,grade) {
            alert(this.name + " , " + this.gender + " ,今年" + this.age + " ,在" + school + "上" + grade);                                
    }
}
var xh = {
        name : "小红",
        gender : "女",
        age : 18
}
xw.say();

如何用xw的say方法来显示xh的数据呢。

对于call可以这样：
xw.say.call(xh);

对于apply可以这样：
xw.say.apply(xh);

而对于bind来说需要这样：
xw.say.bind(xh)();

如果直接写xw.say.bind(xh)是不会有任何结果的，
看到区别了吗？call和apply都是对函数的直接调用，
而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。


而对于有参数的 say1 ，该如何调用呢？

xw.say.call(xh,"实验小学","六年级");   
xw.say.apply(xh,["实验小学","六年级郑州牛皮癣医院"]);
xw.say.bind(xh,"实验小学","六年级")();


看到区别了吗，call后面的参数与say方法中是一一对应的，
而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。

由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。
xw.say.bind(xh)("实验小学","六年级");


https://www.cnblogs.com/cosiray/p/4512969.html



=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

问题：new person . new person()有什么区别

----------------------------------

答： 没有区别，但是要注意最后面加 .name的情况。

function Fn() {
    this.age = 1;
}
Fn.age = function () {
    this.age = 10
}

var a = new Fn.age;           // 实例
var b = new Fn.age().age;     // 10
var c = new Fn().age;         // 1

//new 的运算优先级要小于 . 的运算优先级

//new的必须是函数，如果是属性，会报错，没有constructor
// var a 先调用Fn.age, 再 new 。
//而因为Fn.age 是函数，所以可以new 成功
//而 new 一个函数，得到的是这个函数的实例，a.age = 10


// var b 这个时候，
因为有 (), 所以先执行 new Fn.age（new Fn.age()一样。），
然后再直接调用这个实例的age属性（为10） ，把 10 赋值给 b 

// var c 同样因为有 ()，所以步骤是 先 new Fn（或者写成 new Fn()）,
然后再调用这个实例的age属性，赋值给c
因为new的函数是Fn (它的age是1) ，而不是Fn.age(这个age是10)
所以 c = 1

//这里的Fn有age这个属性吗？从哪里看？
//Fn有age这个属性，console.log(Fn)



=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

问题：a => a+1 	、 	a => {a+1} 这两个分别是什么意思

----------------------------------

答： 

a => a+1
a => {a+1}


-----
a => a + 1

var f1 = a => a + 1

等价于

var f1 = function (a) {
	return a+1
}

console.log(f1(3))	//4

-----

a => { a + 1 }

var f2 = a => { a + 1 }

等价于 


var f2 = function (a) {
	a + 1
}

//这个就是单纯的  a + 1，也没有赋值，也没有返回，在我看来，没有任何意义





=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================






=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================

问题：原型和原型链

----------------------------------

一. 普通对象与函数对象
JavaScript中，对象分为两种：
普通对象 	（即：typeof 的类型为 Object）
函数对象		（即：typeof 的类型为 Function）
Object 、Array、Function 是 JS 自带的函数对象

所有 typeof 返回“function”的对象都是函数对象。也称这样的对象为构造器（constructor）

函数对象怎么得来的？

function test(){} 
var test2=function(){}; 
var test3=function test4(){}; 
var test5=new Function();

所有通过 new Function() 得到的对象都是  函数对象
也只有通过 new Function() 的才是 函数对象

其他的new Object() 、new Array() 、new Date() 这些 typeof 都是 Object


----------------------------------



var o1 = {}; 
var o2 =new Object();
var o3 = new f1();

function f1(){}; 
var f2 = function(){};
var f3 = new Function('str','console.log(str)');

console.log(typeof Object); //function 
console.log(typeof Function); //function  

console.log(typeof f1); //function 
console.log(typeof f2); //function 
console.log(typeof f3); //function   

console.log(typeof o1); //object 
console.log(typeof o2); //object 
console.log(typeof o3); //object

//这里面有好多和我想的不一样
//参考其他的文章之后，了解了。
https://www.cnblogs.com/baotongliu/articles/2361727.html



二. 构造函数

无论什么函数：
只要通过 new 操作符来调用，那就是作为构造函数使用，此时this指向new出的实例
如果不通过 new 操作符来调用，那就是作为普通函数使用；此时，在非严格模式下this都指向window

function Foo(name){
	this.age = age;
}

//当构造函数用：this都指向实例
console.log(new Foo('bty1'));   //Foo {name: "bty1"}

//当普通函数用：this都指向window
Foo('bty1');
console.log(window.age);  //'bty1'	本来window是没有age属性的，通过普通函数，this添加了age属性



本质区别
无论是构造函数还是非构造函数，两者并没有实质性的区别；
构造函数可以作为普通函数使用，普通函数也可以作为构造函数来用；首字母大小写仅仅是为了在开发中能易于区分他们。


实例的构造函数属性（constructor）指向构造函数。（觉得这句话说的不太准确）


三. 原型对象

在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。
其中每个函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。


重要结论：
每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性

什么是原型对象？

构造函数有一个 prototype属性，这个属性的值是一个 地址指针，
指向 内存中的一个对象，这个对象就叫做prototype对象，也就是原型对象 


在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，
这个属性（是一个指针）指向 prototype 属性所在的函数（Person）

Person.prototype.constructor === Person   	//true

person1.constructor === Person 				//true

person1.__proto__.constructor === Person 	
（我认为 person1.constructor 是 person1.__proto__.constructor 的缩写）
（准确的说，不能说是缩写，而是person1没有constructor，然后通过原型链向上找，
找到 __proto__ 的 constructor）


原型对象（Person.prototype）是 构造函数（Person）的一个实例。（这个有点理解模糊）
//这句话有问题。	本质上 原型并不是构造函数的实例
//只是文章作者这么比喻，目的是让人容易理解。
//为了有个正确的认知，不要这么认为，这句话是错的。

原型对象是在函数创建的时候自动获得的一个对象，并不是构造函数的一个实例。
原型对象是构造函数的实例这句话感觉不妥当啊。
而且如果照此理解，那么原型对象与该类型的实例就没有区别了哦


高程红宝书说，构造函数的原型对象并不是构造函数的一个实例。
只是构造函数的一个属性，这个属性是自动获得的。
Person.prototype != Person. 
Person.prototype.constructor == Person.


Person.prototype instanceof Person //false


（上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性。--------这个好像写的不对，person1 和 person2.其实并没有constructor 这个属性，这是属性是属于Person的原型对象的。只是person1 和 person2可以继承原型对象的constructor这个属性。还有person1与Person2这两个实例其实与构造函数Person并没有直接关系，person1与Person2是与Person的原型对象才有直接关系。
（我们要记住两个概念（构造函数，实例）：
person1 和 person2 都是 构造函数 Person 的实例 
一个公式：
实例的构造函数属性（constructor）指向构造函数。）这个总结好像有问题......




原型对象其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说到函数对象都有prototype属性））




其实我觉得楼主是想要解释为什么构造函数的原型对象也有constructor这个属性。不过我觉得楼主你这里说的的确有点问题。var A = new Person(); 这里的new在背后到底帮我们做了哪些事情？
第一步： let A = { }; 
第二步： A.__proto__ = Person.prototype;
第三步: Person.call(A);
第四步： return A。
并没有你在上面说的Person.prototype = A这么一步流程；如果要说是大致是这么个过程的话，其实也不对，因为他们两个是独立的关系[ 硬要说有关系的话，应该是A包含Person.prototypr ]。至于为什么原型对象上有constructor，我觉得没必要解释，或者可以看一下我在下面37楼评论的回复。它就是内置的默认属性，如果要搞事情的话，可能还会问：为什么对象都有__proto__属性？本来就是js语言内置的默认属性，该怎么解释呢？楼主可以在这个地方考虑修改一下，因为我一开始看到你这个表达式不得不说有点懵逼。。。


博主的写的挺好的，但是下面这个结论还是不敢苟同的
结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。
岂不是Person.prototype的__proto__还是指向Person.prototype,然而并不是，应该指向的是Object.prototype, 
Person.prototype.__proto__ === Object.prototype //true


关于第二大点，
“这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person“
“ console.log(person1.constructor == Person);//true“
“console.log(person2.constructor == Person); //true”
我觉得这里的说法有点出入
如果直接打印person1和person2对象，就会发现并没有发现有constructor属性。打印内容如下
{age:28
job:"Software Engineer"
name:"Zaxlct"
sayName:ƒ ()
__proto__:Object}
那为什么person1.constructor == Person 这个会是true，实际是因为在person1中没有找到constructor属性，顺着__proto__往上，找到了Person.prototype，而在这里才找到的constructor，而这个constructor是指向Person的，所以结果才会是true
但是这并不能说是实例上有一个constructor属性，我觉得这容易产生误解。
以上是个人观点，有错误请指正，谢谢。


person1、person2并没有constructor，是在父类中找的。console.log(person1.constructor === Person.prototype.constructor);就说明了一点。

当你访问实例（person1）上没有属性时，他就会去原型链上找，结果找到了原型对象上有constructor属性，就将值返回回来，最终返回true，这就是原型链嘛，如果有人要反驳，你要他把Person.protype = {},然后输出person1.constructor，会输出Object



Function.prototype.prototype就是undefined,
根对象object是没有prototype的


对所有对象都有__proto__这句话有疑惑 
var a ＝ ｛｝，这个a有__proto__属性，
如果是这样创建对象：
var b ＝ Object.create（null）
b是没有__proto__这个属性的，但b是对象！
想问下有人知道为什么吗！


Object.create() 这个方法本来就是用来修改对象的 __proto__ 的指向的。Object.create(null) 就说明产生的对象没有 __proto__ 属性咯，除了这种情况外这个说法就是对的。

Object.create()这个方法本来就是用来创建无原型对象的 顾名思义 其实也就是没有__proto__



博主大部分都分析的可以了，就是原型链没有说清楚，导致评论出现误解，实例没有的属性，js会尝试往原型对象上找，原型对象上没有，再往原型对象的-proyo-（Object.prototype）上找，最终会找到Object.prototype._proto_(他就是原型链的终点null)，找到就返回对应的值，没找到就返回undefined



四. __proto__

JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__ 的内置属性，用于指向创建它的构造函数的原型对象。


五. 构造器


var obj = {}
它等同于下面这样：
var obj = new Object()


六. 原型链


小测试来检验一下你理解的怎么样：

1.person1.__proto__ 是什么？					√
2.Person.__proto__ 是什么？					√
3.Person.prototype.__proto__ 是什么？		√
4.Object.__proto__ 是什么？					√
5.Object.prototype.__proto__ 是什么？		(√)


答案：
第一题：√
因为 person1.__proto__ === person1 的构造函数.prototype
因为 person1的构造函数 === Person
所以 person1.__proto__ === Person.prototype

第二题：√
因为 Person.__proto__ === Person的构造函数.prototype
因为 Person的构造函数 === Function
所以 Person.__proto__ === Function.prototype

第三题：√
Person.prototype 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。
因为一个普通对象的构造函数 === Object
所以 Person.prototype.__proto__ === Object.prototype

第四题：√
参照第二题，因为 Person 和 Object 一样都是构造函数（这么说不准确）
应该说Object 是一个 函数对象（即：typeof Object 为 function）
所以Objcet的构造函数是Fucntion
所以 Object.__proto__ === Function.prototype

Object.__proto__.__proto__ === Object.prototype


第五题：√
Object.prototype 对象也有__proto__属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。
Object.prototype.__proto__ === null



七. 函数对象 （复习一下前面的知识点）

所有函数对象的__proto__都指向Function.prototype，它是一个空函数（Empty function）


Number.__proto__ === Function.prototype  // true
Number.constructor == Function //true

Boolean.__proto__ === Function.prototype // true
Boolean.constructor == Function //true

String.__proto__ === Function.prototype  // true
String.constructor == Function //true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Object.__proto__ === Function.prototype  // true
Object.constructor == Function // true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Function.__proto__ === Function.prototype // true
Function.constructor == Function //true

Array.__proto__ === Function.prototype   // true
Array.constructor == Function //true

RegExp.__proto__ === Function.prototype  // true
RegExp.constructor == Function //true

Error.__proto__ === Function.prototype   // true
Error.constructor == Function //true

Date.__proto__ === Function.prototype    // true
Date.constructor == Function //true


以最后一行：Date.constructor == Function //true 	解释
Date本身并没有constructor，它的constructor其实是 Date.__proto__.constructor
而Date的 __proto__ 找的是 Date的构造函数 的 prototype
而Date是 函数对象，那么它的构造函数就是 Function
即：	 Date.__proto__.constructor 等价于 Function.prototype.constructor
也就指向 Function 本身。

-----



Function.prototype也是唯一一个typeof XXX.prototype为 function的prototype。其它的构造器的prototype都是一个对象


console.log(typeof Function.prototype) // function
console.log(typeof Object.prototype)   // object
console.log(typeof Number.prototype)   // object
console.log(typeof Boolean.prototype)  // object
console.log(typeof String.prototype)   // object
console.log(typeof Array.prototype)    // object
console.log(typeof RegExp.prototype)   // object
console.log(typeof Error.prototype)    // object
console.log(typeof Date.prototype)     // object
console.log(typeof Object.prototype)   // object

所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。
所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind


八. Prototype


在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。



当我们创建一个对象时：
var Person = new Object()
Person 是 Object 的实例，所以 Person 继承了Object 的原型对象Object.prototype上所有的方法：


当我们创建一个数组时：
var num = new Array()
num 是 Array 的实例，所以 num 继承了Array 的原型对象Array.prototype上所有的方法：

但实际上 Array.prototype  是一个空数组 	[]

我们可以用一个 ES5 提供的新方法：Object.getOwnPropertyNames
获取所有（包括不可枚举的属性）的属性名不包括 prototy 中的属性，返回一个数组：

var arrayAllKeys = Array.prototype; // [] 空数组
// 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.__proto__ 中的属性)
console.log(Object.getOwnPropertyNames(arrayAllKeys)); 
/* 输出：
["length", "constructor", "toString", "toLocaleString", "join", "pop", "push", 
"concat", "reverse", "shift", "unshift", "slice", "splice", "sort", "filter", "forEach", 
"some", "every", "map", "indexOf", "lastIndexOf", "reduce", "reduceRight", 
"entries", "keys", "copyWithin", "find", "findIndex", "fill"]
*/

这样你就明白了随便声明一个数组，它为啥能用那么多方法了。

细心的你肯定发现了Object.getOwnPropertyNames(arrayAllKeys) 输出的数组里并没有 constructor/hasOwnPrototype等对象的方法（你肯定没发现）。
但是随便定义的数组也能用这些方法

var num = [1];
console.log(num.hasOwnPrototype()) // false (输出布尔值而不是报错)

这时为什么？

因为Array.prototype 虽然没这些方法，但是它有原型对象（__proto__）


九. 复习一下

所有函数对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function）

所有对象的 __proto__ 都指向其构造器的 prototype



function Person(name) {
    this.name = name
}
// 重写原型
Person.prototype = {
    getName: function() {}
}
var p = new Person('jack')
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // false
（这里为什么是 false）

记住一句话：
constructor始终指向创建当前对象的构造函数。
重写的原型的属性是一个对象。而这个对象是 Object 创建的。所以这个对象的constructor指向Object

要区别的是，最开始Person的prototype的创建对象是Person，所以这个constructor指向Person

p.__proto__ 现在是 {
    getName: function() {}
}
而p.constructor.prototype 其实是 Object.prototype,
而Object.prototype是一个空对象 {}


下面帮助加深理解
var arr = [1, 56, 34, 12];// 等价于 var foo = new Array(1, 56, 34, 12);
console.log(arr.constructor === Array); // true

var Foo = function() { };  // 等价于 var foo = new Function();
console.log(Foo.constructor === Function); // true

// 由构造函数实例化一个obj对象
var obj = new Foo();
console.log(obj.constructor === Foo); // true

// 将上面两段代码合起来，就得到下面的结论
console.log(obj.constructor.constructor === Function); // true



十. 原型链


Function.__proto__ === Function.prototype // true

Function.prototype 是一个空函数// function () {}





Function.prototype.__proto__ === Object.prototype //true

注意，只有Function.prototype 是函数对象（即：typeof 为 function），不是普通对象（普通对象找Object）。
按理来说，函数对象的 __proto__ 应该是其构造函数的 prototype，至少也是Function.prototype
而不应该是 Object.prototype。

其实这一点我也有点困惑，不过也可以试着解释一下。
Function.prototype是个函数对象，理论上他的__proto__应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。
JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，
指向Object.prototype。Object.prototype.__proto__ === null，保证原型链能够正常结束。



十一 总结
原型和原型链是JS实现继承的一种模型。
原型链的形成是真正是靠__proto__ 而非prototype


要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？

var animal = function(){};
var dog = function(){};

animal.price = 2000;
dog.prototype = animal;
var tidy = new dog();
console.log(dog.price) //undefined
console.log(tidy.price) // 2000

实例（tidy）和 原型对象（dog.prototype）存在一个连接。
不过，要明确的真正重要的一点就是，这个连接存在于实例（tidy）与构造函数的原型对象（dog.prototype）之间，
而不是存在于实例（tidy）与构造函数（dog）之间。





=============================================================================
=============================== 结束开始分隔符 ===============================
=============================================================================





沃信科技面试题

问题：
请简单描述浏览器渲染引擎和js引擎的功能

-----
渲染引擎负责对网页语法的解释（如HTML、XML等）并渲染网页（CSS）。
渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。

Trident（IE）
Gecko（firefox）猎豹浏览器、360极速浏览器、百度浏览器
WebKit（safari）	早期opera和chrome都使用WebKit
Blink（Chrome）

---

JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。
即负责对JavaScript脚本的解释与执行。

V8（Chrome）
Chakra （IE）新版的IE（IE9及之后的版本），Edge，老版IE仍然使用的是Jscript。
Nitro（SquirrelFish）（Safari）
Carakan（Opera）
Mozilla（firefox）


=====

问题：
请描述浏览器渲染页面的工作步骤

-----

1.根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS，阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。

2.构建渲染树（Render Tree）。

3.页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器对页面进行重绘或是重排。




=====

问题：
请简单说明cookies，localStorage和sessionStorage的区别

-----






=====================


问题；
将数组[2,3,3,3,5,2,5,4,4]中的重复数据去掉（js代码）

-----
let i = [1,23,34,56,1,1,1,23,33,34]
console.log([...new Set(i)])
-----

这里我是用es6的新特性----Set()
注意上面使用了   new Set(i)  这时的返回值是对象结构
可以使用	[...]	来转换成数组格式

-----

或者使用另一种方法	Array.from()	来转换成数组
console.log(Array.from(new Set(i)))

Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。
-----


=====================



问题：
请将字符串'asdfssaaasasasasaa'中出现最多的字符找出来，并打印该字符和对应出现的次数（js代码）


-----
var str = 'asdfssaaasasasasaa';

var obj = {};
for (var i = 0; i < str.length; i++) {
   if (!obj[str.charAt(i)]) {
       obj[str.charAt(i)] = 1;
   } else {
       obj[str.charAt(i)]++
   }
}

var max = 0,
    name = "";
for (var i in obj) {
    if (obj[i] > max) {
        max = obj[i];
        name = i;
    }
}

console.log('出现次数最多的是:' + name + '出现了' + max + '次'); //出现次数最多的是:a出现了9次 

-----

// 很牛的reduce方法
var testStr = 'asdasddsfdsfadsfdghdadsdfdgdasd';
var testArray = testStr.split('');
var a = testArray.reduce(function(prev,next){
  if(next in prev) {
    prev[next]++;
  }else {
    prev[next] = 1;
  }
  return prev
},{})
console.log(a)

--
对reduce的理解：

reduce(callback,initiaValue)会传入两个变量，回调函数(callback)和初始值(initiaValue)。

假设函数有个传入参数，prev和next，index和array。 Prev和next是你必须要了解的。

当没有传入初始值时，prev是从数组中第一个元素开始的，next是第二个元素。

但是当传入初始值（initiaValue）后,第一个prev将是initivalValue，next将是数组中的第一个元素。



=====================








问题：
将'hello world'中的空格去掉并打印


-----
let i = 'hello wrold'
console.log(i.split(' ')[0]+i.split(' ')[1])
-----








====================================
EP停车开发组前端工程师面试题

问题：
如何居中DIV？（请作答至少两种方式）


----

使用 margin:0 auto 

<div style="border: 1px solid #000;width: 200px; height:100px;margin:0 auto">a</div>

----

让绝对定位的div居中

 div {
 	position: absolute;
 	width: 300px;
 	height: 300px;
 	margin: auto;
 	top: 0;
 	left: 0;
 	bottom: 0;
 	right: 0;
 	background-color: pink;	/* 方便看效果 */
}

这里的前提是position: absolute;
单独 margin: auto;
或者单独 left: 0; right: 0;
都不行，必须一起使用


这里使用的是 margin 为 auto，然后 left 为具体像素的使用


----


水平垂直居中一

 确定容器的宽高 宽500 高 300 的层
 设置层的外边距
 
 div {
 	position: relative;		/* 相对定位或绝对定位均可 */
 	width:500px;
 	height:300px;
 	top: 50%;
 	left: 50%;
 	margin: -150px 0 0 -250px;     	/* 外边距为自身宽高的一半 */
 	background-color: pink;	 	/* 方便看效果 */
 
}

或者

<div    style="border: 1px solid #000;
        width: 200px; 
        height:100px;
 		top: 50%;
        left: 50%;
        position: absolute;
        margin: 0px 0 0 -100px;">
a</div>

这里使用的是 对齐（left）为百分比，然后margin 为具体像素的使用


注意：这里有个细节问题。如果使用left： 50%， 那么margin: 上 右 下 左 。 这四个参数中（右参数无效，只能用左参数），这是因为使用左对齐。
其它三个对其方式同样原理


此外，w3c默认是float：left 	(默认左对齐)
所以这时使用margin-left:10px;  是有效的
但是margin-right: 20px;  无效。
margin-right 配合 float:right 才有效果
同时float: right 这个时候 margin-left 无效
-----


水平垂直居中二

 未知容器的宽高，利用 `transform` 属性
 
 div {
 	position: absolute;		/* 相对定位或绝对定位均可 */
 	width:500px;
 	height:300px;
 	top: 50%;
 	left: 50%;
 	transform: translate(-50%, -50%);
 	background-color: pink;	 	/* 方便看效果 */
 
}

或者

<div    style="border: 1px solid #000;
        width: 200px; 
        height:100px;
 		top: 50%;
        left: 50%;
        position: absolute;
        transform: translate(-50%, 0%);">
a</div>


-------


水平垂直居中三

 利用 flex 布局
 实际使用时应考虑兼容性
 
 .container {
 	display: flex;
 	align-items: center; 		/* 垂直居中 */
 	justify-content: center;	/* 水平居中 */
 
 }
 .container div {
 	width: 100px;
 	height: 100px;
 	background-color: pink;		/* 方便看效果 */
 }  



-----------

补充1：
left等定位属性，要使用时，它必须是已定位的元素。（absolute，relative，fixed）
eg：img{position:absolute;left:100px} 
如果去掉position：absolute，则left失效。
对float：left这种浮动元素也是失效，反正就是定位了才让用。
拓展一种居中用法，先定位，再设置 left：0;right：0;margin:auto 可以使元素垂直居中。 
设置 top:0;bottom:0;margin:0 可以使元素水平居中。
当然，设置四个值都是0；margin：0；后，这个元素就在正中间了。如果不设置元素大小，就平铺了。



-----
补充2：
left: 0;
right: 0;
top: 0;
bottom: 0;

把元素充满了容器，同时自身指定了宽度，总宽度（固定） = width（固定） + margin-left + margin-right;

margin: auto;

当margin设置为auto的时候，左右边距会平分，元素自然就居中了，垂直居中原理一致。


以水平方向为例子，绝对定位的元素:

left + 
margin-left + 
border-left + 
padding-left + 
width + 
padding-right +
border-right +
margin-right +
right = 
包含块

width为定值，padding, border默认为0/none，left、right为0，
那么margin-left和margin-right为auto，则平分剩余空间，居中。

=======

问题：
列出5种语义化标签。

-----

一、什么是HTML语义化标签
语义化的标签，旨在让标签有自己的含义

eg:
<p>一行文字</p>
<span>一行文字</span>

p 标签与 span 标签的区别之一就是：p 标签的含义是：段落。而 span 标签责没有独特的含义。

二、语义化标签的优势
代码结构清晰，方便阅读，有利于团队合作开发。
方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。
有利于搜索引擎优化（SEO）

三、常见的语义化标签
因此我们在写页面结构时，应尽量使用有 语义的HTML 标签

<title>：页面主体内容。
<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。
<ul>：无序列表。
<li>：有序列表。
<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。
<nav>：标记导航，仅对文档中重要的链接群使用。
<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。
<article>：定义外部的内容，其中的内容独立于文档的其余部分。
<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。
<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。
<footer>：页脚，只有当父级是body时，才是整个页面的页脚。
<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。
<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。
<em>：将其中的文本表示为强调的内容，表现为斜体。
<mark>：使用黄色突出显示部分文本。
<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。
<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。
<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。
<blockquoto>：定义块引用，块引用拥有它们自己的空间。
<q>：短的引述（跨浏览器问题，尽量避免使用）。
<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。
<abbr>：简称或缩写。
<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。
<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。
<del>：移除的内容。
<ins>：添加的内容。
<code>：标记代码。
<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）
<progress>：定义运行中的进度（进程）。



=====


问题：
简述cookies，sessionStorage，和localStorage的区别？




问题：
var array=【1，30，48，21，1080】；array.sort();这时array的值是？

-----
果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。

[1, 1080, 21, 30, 48]

具体详情：
https://www.w3school.com.cn/js/jsref_sort.asp

扩展：
message = Hello
message.split('').reverse().join('')	//olleH		先拆分，再颠倒，最后组合

=====

问题：
对象浅拷贝和深拷贝的区别？简述实现深拷贝方法？

-----

如何区分深拷贝与浅拷贝，简单点来说就是：
假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝。
如果B没变，那就是深拷贝。

1.递归复制所有层级属性。

function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);

注意：array数组的类型就是 Object，并没有数组类型。
这里使用 	for(key in obj)		不管是对象还是数组都可以遍历。

2.JSON对象的parse和stringify


function deepClone(obj){
    let _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}    
let a=[0,1,[2,3],4],
    b=deepClone(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);

//JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。
//JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。
//parse()自动根据字符串转换成对应的格式

3.JQ的extend方法。

$.extend( [deep ], target, object1 [, objectN ] )
deep表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝
target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。
object1  objectN可选。 Object类型 第一个以及第N个被合并的对象。 


let a=[0,1,[2,3],4],
    b=$.extend(true,[],a);
a[0]=1;
a[2][0]=1;
console.log(a,b);

-----

详细：https://www.cnblogs.com/echolun/p/7889848.html

扩展：深拷贝的库
**jquery**
使用方法：
let targetObj = $.extent(true,{},sourceObj)
**lodash函数库**
使用方法：
npm install lodash
**es5写法**
let lodash = require('lodash')
**es6写法**
import lodash from 'lodash'

let targetOj = lodash.cloneDeep(sourceObj)


=====


问题：
下面这个ul，如何实现点击每一列的时候输出其index？
<ul id="box">
	<li>a</li>
	<li>b</li>
	<li>c</li>
</ul>

-----
$("#box li").click(function(){ alert($(this).index()); })

=====


问题：
列举至少3种字符串  var s = '234'  转数字的方法？

-----

parseInt(num); // 默认方式 (没有基数)
parseInt(num, 10); // 传入基数 (十位数)
parseFloat(num) // 浮点数
Number(num); // Number 构造器
~~num //按位非
num / 1 // 除一个数
num * 1 // 乘一个数
num - 0 // 减去0
+num // 一元运算符 "+"

-----

1.parseInt

let i = '123';
let b = parseInt(i)
console.log(typeof i +'-----'+ typeof b)	//string-----number

一些常见陷阱：
parseInt('08') 		// returns 8
parseInt('0x122') 	// returns 290
parseInt('44.jpg') 	// returns 44

parseInt: 没有传入基数时，默认是传入的基数为10 parseInt(num, 10)，
如果它以 “0x” 或 “0X” 开头，将以 16 为基数。
如果你不知道num属性的类型，不要使用parseInt进行字符串转数字。


2.parseFloat

如果你不解析16进制数，这是一个非常好的选择。例如：

parseInt(-0xFF) // returns -255
parseInt("-0xFF") // returns -255
parseFloat(-0xFF) // returns -255
parseFloat("-0xFF") // returns 0

注意：字符串中的负十六进制数字是一个特殊情况,
如果你用parseFloat解析，结果是不正确的。为了避免程序出现NaN的情况，应该检查转化后的值。

parseFloat('44.jpg') // returns 44

parseFloat: 转换十六进制数时要小心，如果你不知道要转换对象的类型，不要使用parseFloat。

3.~~num //按位非

~~1.23 			// returns 1
~~"1.23" 		// returns 1
~~"23" 			// returns 23
~~"Hello world" // returns 0

4.Number

Number与以上提及的转换方式一样存在这样的问题，解析时试图找出你给他的数字：
Number("023") // returns 23
Number(023) // returns 19
注意：023实际上是一个八进制数，无论你怎么做，都是返回19；对于没有单引号或双引号的十六进制数一样。
如果对象的值无法转换为数字，那么 Number() 函数返回 NaN。
Number也是JsPerf中最慢的之一。
Number：几乎不用它。

5.一元运算符

"1.23" * 1 		// returns 1.23
"0xFF" - 0 		// returns 255
"0xFF.jpg" / 1 	// returns NaN
+"023" 			// returns 23


=====

问题：
class A();  typeof A 答案是？

-----

function (或者说 object)

======




问题：
如何处理多个异步情况？
如fn1，fn2，fn3都是异步，其中fn1返回A，fn2返回B，fn3的请求参数中带A，B才能发起请求。


-----

方案一，Promise.all形式：

var promise1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log(1);
        resolve()
    }, 0);
    
});
var promise2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log(2);
        resolve()
    }, 0);
});
Promise.all([promise1, promise2]).then(function(res) {
  console.log(3)
});



方案二，callback形式：

var index = 0

function C(){
    console.log(3);
}

setTimeout(() => {
    console.log(1);
    index++;
    if(index === 2){
        C()
    }
}, 0);

setTimeout(() => {
    console.log(2);
    index++;
    if(index === 2){
        C()
    }
}, 0);


========




问题：
正则实现 trim()功能


-----

function trim(str) { 
var newStr = str.replace(/^\s*$/g,'') 
return newStr; 
} 

//这个网上找到，经过调用，是错的
//var reg = /^\s+|\s+$/gi
//这个是我自己写的


======


问题：
如何快速打开一个含有多张大图的网页，而不会有白屏？

-----

压缩图片

懒加载和预加载

https://www.cnblogs.com/ilmare-notebook/p/9346996.html





问题：


JS计算中float计算精度问题

0.1 + 0.2 != 0.3 // true	0.1 + 0.2 = 0.30000000000000004

---
let i = 0.07;
let t = i * 100;	//	t = 7.000000000000001 


---
console.log(6.8-0.9);
console.log(6.8-0.8);
console.log(6.8-0.4);
console.log(6.8-0.3);
//结果
5.8999999999999995
6
6.3999999999999995


-----

解决方案
对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。

对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）

比如0.07
建议parseInt（i * 100）最后再 / 100


=====







网旭科技面试题

问题1：按优先级排序下列css选择器

1	a
2	#id
3	.class
4	.class1 .class2(中间有个空格)
5	.class1.class2(中间没有空格)
6	a:hover
7	a[href]
8	xxx !important
9	style="xxx"
10 	继承来的属性
11	*

问题2：如何实现水平居中和垂直居中

问题3：使用CSS选择器选择在同一级别的子元素中位置为1.4.7.10...（第一个元素位置为1）的li元素

问题4：link和@import的区别

问题5：请用纯CSS创建一个三角形

问题6：png，jpg，svg这些图片格式解释一下，分别什么时候用。

问题7：请描述一下cookies，sessionStorage，localStorage的区别

问题8：写一个去重函数，去除数组中重复的元素，如如数组为：[0,3,4,3,5,6,7,4,9,45,45,12,12],
请写一个函数，输入为该数组，输出为该数组去除重复元素后的数组

问题9：请构建一个函数delayedCallback，调用delayedCallback(fn)时，它会在1秒后调用函数fn，
并且返回一个函数用于取消该延迟调用。

问题10：写一个方法，返回传入数组的最大和子集和最大和。


-----
问题1

答：

1	a 												1
2	#id 											100
3	.class 											10
4	.class1 .class2(中间有个空格) 					10+10=20 
5	.class1.class2(中间没有空格) 						10+10=20
6	a:hover 										1+10=11
7	a[href] 										1+10=11
8	xxx !important 									最高
9	style="xxx" 									1000
10 	继承来的属性 										0
11	* 												0

所以：

8 > 9 > 2 > 4 = 5 > 6 = 7 > 3 > 1 > 10 > 11

4表示 class1 下的子元素 class2
5表示 同时拥有 class1 和 class2 的元素
通配符权重 大于 继承的权重


问题2

答：

li:nth-child(3n + 1) {
    background: black
}


-----

问题3

答：

水平居中

<div></div>
.div {
	margin: 0 auto;
}

水平垂直居中

.div {
	height: 100px;
	width: 100px;
	left: 50%;
	top: 50px;
	position: absolute;
	margin-left: -50px;
	margin-top: -50px;
}


4.答：

两者都是外部引用CSS的方式，但是存在一定的区别：
区别1：link除了引用样式文件，还可以引用图片等资源文件，而@import只引用样式文件
区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。

import的写法比较多：推荐使用 @import url(index.css);


扩展： js import 和 require 的区别

Require是CommonJS的语法，CommonJS的模块是对象，输入时必须查找对象属性。

// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;

整体加载fs模块（即加载fs所有方法），生成一个对象"_fs"，然后再从这个对象上读取三个方法，这叫“运行时加载”，因为只有运行时才能得到这个对象，不能在编译时做到静态化。


ES6模块不是对象，而是通过export命令显示指定输出代码，再通过import输入。

import { stat, exists, readFile } from 'fs';

从fs加载“stat, exists, readFile” 三个方法，其他方法不加载，


=====


5.答：
<div></div>

div {
    width: 0;
    height: 0;
    border-width: 0 40px 40px;
    border: 40px solid;
    border-color: transparent transparent red;
}

//三角形是因为 div 的宽高都是0，凑到了一个点上，所以最终结果是三角形
//width: 40px; height: 40px; border: 40px solid 这种情况下
//中间空的正方形就是div，四边围着的梯形就是border，画一下，f12查看一下，一目了然。



扩展：实现带边框的三角形

带边框的三角形是指为三角形添加其它颜色的边框，如同为元素添加border一样：

带边框的三角形
由于不能继续通过为已有三角形设置border的方法来为其设置边框（因为三角形本身就是利用border实现的），所以只好另想办法。而能想到的一个最自然的方法就是三角形叠放，即把当前三角形叠放在更大的三角形上方，上图所示的实现方法就是把黄色三角形放在了尺寸更大的蓝色三角形上。

<div id="blue"><div>

#blue {
    position:relative;
    width: 0;
    height: 0;
    border-width: 0 40px 40px;
    border-style: solid;
    border-color: transparent transparent blue;
}

#blue:after {
    content: "";
    position: absolute;
    top: 1px;
    left: -38px;
    border-width: 0 38px 38px;
    border-style: solid;
    border-color: transparent transparent yellow;
}

学会了带边框三角形的绘制，那么实现类似如下三角形箭头自然也是不在话下了：

#blue:after {
    content: "";
    position: absolute;
    top: 2px;
    left: -38px;
    border-width: 0 38px 38px;
    border-style: solid;
    border-color: transparent transparent #fff;
}

-----
问题6
答；
SVG
全称为Scalable Vector Graphics，意思为可缩放的矢量图形.
svg是二维矢量图形的一种图形格式

1.使用 XML 格式定义图形
2.图像在放大或改变尺寸的情况下其图形质量不会有所损失
3.由于svg是xml文件，任何文本编辑器都可以对它进行编辑，而且更适合seo优化。
4.Svg文件比jpg格式要小很多

SVG在HTML5中主要用来绘制图形需要canvas和JS配合

-----
问题8

答：
function removeRepeat (arr) {
	let newArr = [];
	for (let i = 0; i < arr.length; i++) {
		if (newArr.indexOf(arr[i]) == -1) {
			newArr.push(arr[i])
		}
	}
	return newArr;
}

console.log(removeRepeat([0,3,4,3,5,6,7,4,9,45,45,12,12]))


-----

问题9
答：
function delayedCallback (fn) {
	var time = setTimeout(fn,3000);
	var that = this;		//这里我开始弄错了，返回的匿名函数其实是一个闭包，
    console.log(time)		//一直存在内存中，可以访问delayedCallback中的time
	return function () {
        console.log(time)		
		clearTimeout(time)	//我开始写成that.time，这样反而访问不到
        console.log('cancle')
	}
}

var test = function test () {
    alert(100);
}

var retrunFunc = delayedCallback(test)
retrunFunc()

=====

问题10：

答：

function maxSubsequence(array)
{
    if(array.length < 0) return 0;
    var sum = array[0];
    var temp = array[0];
    var start = 0;
    var startTemp = 0;
    var end = 0;
    for (var i = 1;i<array.length;i++){
        if(temp <= 0){
            temp = array[i];
            startTemp = i;
        }else{
            temp = temp + array[i];
        }
        if(temp > sum){
            sum = temp;
            end = i;
            if(end > start) start = startTemp;
        }else{
            sum = sum;
        }
    }
    console.log(sum + ' : ' + array.slice(start, end + 1));
}

maxSubsequence([1,1,3,-5,1])









=====

webpack打包流程


webpack -g   --save-dev	的区别

-g 表示全局安装
--save 和 --save-dev 表示安装到你的项目根目录，
--save 会把依赖包名称添加到 package.json 文件的 dependencies 下，
--save-dev 则添加到 package.json 文件的 devDependencies 下。
dependencies是运行时依赖，
devDependencies是开发时的依赖。
运行时需要用到的包使用--save，否则使用--save-dev，
如果你还是不知道使用哪个，使用--save即可，以后安装的包同理。




=====
js的数据类型
简单数据类型：	Number 、Boolean、Undefined、String、Null
复杂数据类型：	Object

=====

匿名函数

匿名函数的作用：
1.通过匿名函数可以实现闭包
2.模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，从而节省内存。
（这个往往一般和立即执行函数配合使用）

https://blog.csdn.net/u012149969/article/details/80637339
=====
js闭包
闭包（closure）：闭包就是能够读取其他函数内部变量的函数

function fn1 () {
    var a = 123;
    function fn2 () {		//如果 var bb 接受 fn2，就return bb
        console.log(a)
    }
    return fn2
}

var aaa = fn1();
aaa()

---
function fn1 () {
    var a = 123;
    return function () {		//如果 var bb 接受 fn2，就return bb
        console.log(a)
    }
}
var aaa = fn1();
aaa()

=====

立即执行函数

立即执行函数的两种常见形式：
( function(){…} )()
( function (){…} () )
除了使用()运算符之外，
！，+，-，=等运算符都能起到立即执行的作用。


var i=function (a,b){ return a+b; }(1,2);
//这样也可以调用


立即执行函数的作用一般是防止变量污染

=====

作用域
-----
作用域分为两种
1.全局作用域					//全局变量
2.局部作用域--函数作用域		//局部变量，也就是函数内的变量

--
因为js中没有块级作用域，所以在 if 或是 for 这样逻辑语句中定义的变量都是可以被外界访问到的。
也就是说if 或 for 里面的变量都是全局变量

-----
作用域链

Function对象有一个仅供 JavaScript 引擎存取的内部属性。
这个属性就是[[Scope]]。

=====

垃圾回收机制

-----

1.什么是垃圾
一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

2.如何检垃圾
一种算法是标记 标记-清除 算法，

https://segmentfault.com/a/1190000018605776?utm_source=tag-newest


=====
js this

http://www.ruanyifeng.com/blog/2018/06/javascript-this.html

ES6 this


闭包函数
匿名函数
立即执行函数
嵌套函数
作用域
垃圾回收机制/销毁
---


function print() {
    console.log(foo);
    var foo = 2;
    console.log(foo);
    console.log(hello);
}
print()

//直接报错  hello is not defined		//有个问题，一开始直接报错，后来又是打印2次，到hello再报错
//其实这里如果没有后面的 var foo = 2，会直接报错 foo is not defined
//只是后面有 var foo = 2，foo的检测通过了，这里涉及到声明编译的问题。


var a = 5;
function fuc() {
    a = 0;
    console.log(a)			//0
    console.log(this.a)		//5
    var a ;
    console.log(a)			//0
}

fuc()	和 	new fuc() 的结果分别是什么

//这里也是一样，虽然一开始 a = 0 没有声明，但后最后补齐了 var a，所以这个a是局部变量，不是外面的5


var a = 5;
function fuc() {
    a = 0;
    console.log(a)			// 0		全局变量
    console.log(this.a)		// 0		全局变量
}

fuc()						//这里因为没有声明var a，所以a 默认是外面的全局变量






-----

var name = "222";
var a = {
	name: "111",
	say: function () {
		console.log(this.name);
	}
}
var fun = a.say;
fun();		//222
a.say();	//111
 
var b = {
	name : "333",
	say: function (func){
		func();
	}
}
b.say(a.say);	//222
b.say = a.say;	
b.say();        //333

倒数第二个为什么会打印222

是因为b的say函数中是直接调用的func（），虽然是在b内，但是func在执行的时候并没有绑定在某个对象上，相当于是全局状况下调用，所以打印 ”222“


-----


var val = 1
var obj = {
    val: 2,
    dbl: function () {
        this.val *= 2
        val *= 2
        console.log(val)
        console.log(this.val)
    }
}

obj.dbl()
var func = obj.dbl
func()


//如果dbl中没有声明变量 val ，那么val就会找window全局环境下的val,而不是obj.val这个
dbl: function(){
	var val = 2		//dbl声明val
}


-----


=====

问题：css选择器的权重

-----

内联样式			style=""				1000
id选择器			#id						100			A
类（属性选择器）	.class	[class='abc']	10			B
普通标签			p div					1			C
通配符选择器		*						0 


id选择器的权重>class选择器的权重=属性选择器的权重>元素选择器


//扩展（直接点  空格点）
1. 	p.text 表示的是拥有class= text的p元素，两者是并列同级关系，而不是有class = text的 p的子元素

2. 	有时候写css样式会有进入误区，搞混了
<div class='a b'></div>

//上面表示div有两个class属性， a 和 b
但是在css样式里面要分开写
.a {
	...
}
.b {
	...
}
----这样的写法是正确的
.a .b{ 		//中间有空格，这样的写法是 class = a的元素下面的子元素寻找 class= b 的元素（空格表示后代）
	...
}

找的是

<div class="a">
    123
    <div class="b">234</div> //找的是这个div
</div>

----
.a.b{ 		//中间没有空格，但表达的意思是 拥有 class = b 的 class = a 的元素(两个同时拥有，顺序随便)
	...
}

<div class="b a">

-----
.a,.b{ 		//这样写才是互不关联的 a 和 b 的样式 //用逗号隔开
	...
} 

具体的可以参考：
http://www.divcss5.com/rumen/r50591.shtml

-----

最后h2标签是什么颜色?

<div id="content">
    <div id="main-content">
        <h2>CSS简介</h2>
        <p>CSS（Cascading Style Sheet，可译为“层叠样式表”或“级联样式表”）是一组格式设置规则，用于控制Web页面的外观。</p>
        <div class="paragraph">
        	<h2 class="first">使用CSS布局的优点</h2>
        	<p>1、表现和内容相分离 2、提高页面浏览速度 3、易于维护和改版 4、使用CSS布局更符合现在的W3C标准.</p>
        </div>
    </div>
</div>



#content div#main-content h2{
    color:red;
}
//    100(#content) + 1(div) + 1000(#main-content) + 1(h2) = 202

#content #main-content>h2 {
    color:blue
}
//    100(#content) + 1000(#main-content) + 1(h2) = 201

body #content div[id="main-content"] h2 {
    color:green;
}
//    1(body) + 100(#content) + 1(div) + 10([id="main-content"]) + 1(h2) = 113

#main-content div.paragraph h2 {
    color:orange;
}
// 100(#main-content) + 1(div) + 10(.paragraph) + 1(h2) = 112

#main-content [class="paragraph"] h2 {
    color:yellow;
}
// 100(#main-content) + 10(class="paragraph") + 1(h2) = 111

div#main-content div.paragraph h2.first {
    color:pink;
}
// 1(div) + 100(#main-content) + 1(div) + 10(.paragraph) + 1(h2) + 10(.first) = 123



//上面需要注意的地方是	div.paragraph	div#main-content	div[id="main-content"]
//div.paragraph		表示带有class=paragraph的div--实质为 类选择器（10）+ 普通标签（1）
//div#main-content	表示id=main-content的duv	   --实质为 id选择器（100）+普通标签（1）
//div[id="main-content"]	虽然有id，但是[]	   --实质为 属性选择器（10） + 普通标签（1）


通过比较三个组分来比较特异性：
具有较大A值的特异性更具体; 
如果两个A值相关，则具有较大B值的特异性更具体; 
如果两个B值也相关联，则具有较大C值的特异性更具体; 
如果所有值都绑定，则两个特征相等。



=====

问题：图片格式的区别

----

图片在整个网页中占有重要的地位，大多数的网页的图片占比达到60%左右，所以在不同的场景中使用不同的图片对于web页面的性能会有很大的优化。文本页面常用的图片格式有：gif、png、jpg、webp等。

图片格式的分类：
无压缩：无压缩的图片格式不对图片数据进行压缩处理，能够准确的呈现原图片。bmp格式是其中之一。
无损压缩：压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。
有损压缩。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg。
gif：是一种无损的基于索引色的图片格式，采用的是无损压缩，相对于bmp格式，尺寸更小，并且能够支持透明和动画，但gif只能够存储8位的索引，最多保存256种的颜色，遇到相对复杂的、细节丰富的图片不适合保存为gif，只能适合简单的logo、icon、线框图之类的。
png：png的图片分为png-8和png-24，两者都是采用无损压缩，相比于gif对于透明的支持更好。png-8是基于8位索引色的位图格式，不支持动画，但是在相同质量的情况下，相比gif尺寸更小。png-24是基于直接色的位图格式，图片质量较高，但是尺寸相比于bmp等过大，在相对极高品质的图片要求中更推荐使用jpg。
jpg：jpg是一种有损的基于直接色的图片格式，由于是直接色，jpg可以使用的颜色高达1600w之多，jpg非常适合色彩丰富的图片，并且将图片的尺寸大幅度的减小。
webp:webp（发音weppy）是一种支持有损压缩和无损压缩的图片的格式，派生自图像编码格式VP8，是Google公司在2010年推出的一种图片格式，图片的压缩的体积大约只有jpg的2/3，并且能够节省大量的服务器带宽资源和数据空间。
在面试的情况下，一定要说出上述的几种常见的图片格式（jpg，png，gif，webp），尤其是webp一定要着重提到，相比于其他的格式webp更加的年轻，意味着你是否对新事物是否了解。

WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，
而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性
，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。




=====

问题：JS去重

-----
1、通过删除原数组里面重复的数，进行去重。知识：数组反循环，indexOf。

function removeRepeat(data) {
  for(let i = data.length - 1; i >= 0; i--){
    if (data.indexOf(data[i]) !== i) {
      data.splice(i, 1)		
    }
  }
  return data;
}
//splice删除数组中索引为i的元素，如果后面不加长度（1表示只删除一个），默认后面的全部删除。
//splice改变数组长度和后面元素的索引
//delete	delete data[3] 不改变数组长度，这个索引位置的元素删除，变成undefined


2、添加新数组往里面赋值。
function removeRepeat(data) {
  var newData = []
  for(let i = 0; i < data.length; i++){
    if (newData.indexOf(data[i]) === -1) {
      newData.push(data[i]);
    }
  }
  return newData;
}


3、通过添加新数组、新对象进行赋值。新对象用于判断重复、新数组用于存储值。

function removeRepeat(data) {
  var newData = []
  var val = {}
  for(let i = 0; i < data.length; i++){
    if (!val[data[i]]) {
      val[data[i]] = 1;
      newData.push(data[i]);
    }
  }
  return newData;
}
removeRepeat([1,2,3,4,2,3,1,4,6,3,1])  //  [1, 2, 3, 4, 6]
//这个感觉多此一举


4、最新最方便的数组去重。

function removeRepeat(data) {
  return [...new Set(data)];
}

=====

问题：JS缓存机制


什么是浏览器缓存
Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。浏览器和网站服务器是根据缓存机制进行缓存的

非HTTP协议定义的缓存机制
浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签

<meta http-equiv="Pragma" content="no-cache">
上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。

缓存流程图
利用浏览器缓存的过程:


HTTP缓存机制
根据Response Header里面的Cache-Control和Expires这两个属性，当两个都存在时，Cache-Control优先级较高。

Cache-Control


该字段用于控制浏览器在什么情况下直接使用本地缓存而不向服务器发送请求。一般具有以下值：

Public：指示响应可被任何缓存区缓存。

Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。

no-cache：指示请求或响应消息不能缓存。

no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。

max-age：指示浏览器可以接收生存期不大于指定时间（以秒为单位）的响应。

min-fresh：指示浏览器可以接收响应时间小于当前时间加上指定时间的响应。

max-stale：指示浏览器可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么浏览器可以接收超出超时期指定值之内的响应消息。

Expires（石器时代的缓存机制）


Expires 头部字段提供一个日期和时间，在该日期前的所有对该资源的请求都会直接使用浏览器缓存而不用向服务器请求。

例如：Expires: Sun, 08 Nov 2009 03:37:26 GMT

注意：

1. cache-control max-age 和 max-stale将覆盖Expires header。

2. 使用Expires存在服务器端时间和浏览器时间不一致的问题。

3. 另外有人说Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1。



服务端如何判断缓存已失效
服务端通过If-Modified-Since（Last-Modified）和If-None-Match（Etag）这两个属性的值来判断缓存是否失效的。

Last-Modified/If-Modified-Since

Last-Modified/If-Modified-Since要配合Cache-Control使用。

Last-Modified：响应资源的最后修改时间。

If-Modified-Since：当缓存过期时，发现资源具有Last-Modified声明，则在请求头带上If-Modified-Since（值就是Last-Modified）。服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应HTTP 200整片资源内容（写在响应消息包体内）;若最后修改时间较旧，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

Etag/If-None-Match

Etag/If-None-Match也要配合Cache-Control使用。

Etag：资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。

If-None-Match：当缓存过期时，发现资源具有Etage声明，则在请求头带上If-None-Match（值就是Etag）。服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。

为什么有了Last-Modified还要Etag?
Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。

2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。

3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。

200 OK（from cache）与304 Not Modified的区别
200 OK( from cache )不向服务器发送请求，直接使用本地缓存文件。304 Not Modified则向服务器询问，若服务器认为浏览器的缓存版本还可用，那么便会返回304。

200 OK( from cache ) 出现操作：

1.地址栏回车

2.页面链接跳转

3.前进、后退

304 Not Modified 出现操作：

1.F5刷新

2.新开窗口

缓存的不同来源 
from disk cache：从磁盘中获取缓存资源，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。它的直接操作对象为CurlCacheManager。

from memory cache：从内存中获取资源，等待下次访问时不需要重新下载资源，而直接从内存中获取。

两者区别：当退出进程时，内存中的数据会被清空，而磁盘的数据不会，所以，当下次再进入该进程时，该进程仍可以从diskCache中获得数据，而memoryCache则不行。



不能被缓存的请求
当然并不是所有请求都能被缓存。

无法被浏览器缓存的请求：

HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求
需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的
经过HTTPS安全加密的请求
POST请求无法被缓存
HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存

https://blog.csdn.net/i13738612458/article/details/80383390

=====

问题：JS定时器

-----

1.setTimeout: 设置一个定时器，在定时器到期后执行一次函数或代码段
2.setInterval: 以固定的时间间隔重复调用一个函数或者代码段
3.setImmediate: 在浏览器完全结束当前运行的操作之后立即执行指定的函数(仅IE10和Node 0.10+中有实现)，类似setTimeout(func, 0)
4.requestAnimationFrame: 专门为实现高性能的帧动画而设计的API，但是不能指定延迟时间，而是根据浏览器的刷新频率而定（帧）



-----
// 下面代码执行之后会输出什么？
var intervalId, timeoutId;

timeoutId = setTimeout(function () {
    console.log(1);
}, 300);

setTimeout(function () {
    clearTimeout(timeoutId);
    console.log(2);
}, 100);

setTimeout('console.log("5")', 400);

intervalId = setInterval(function () {
    console.log(4);
    clearInterval(intervalId);
}, 200);

// 分别输出: 2、4、5



-----

setInterval 和 setTimeout的区别？

如果是setTimeout和setInterval的话，它俩仅仅在执行次数上有区别，setTimeout一次、setIntervaln次。

而通过setTimeout模拟的setInterval与setInterval的区别则在于：setTimeout只有在回调完成之后才会去调用下一次定时器，而setInterval则不管回调函数的执行情况，当到达规定时间就会在事件队列中插入一个执行回调的事件，所以在选择定时器的方式时需要考虑setInterval的这种特性是否会对你的业务代码有什么影响？


拓展：

具体写法如下：

函数名，不带参数
setTimeout (test,1000)；           //1秒后执行

字符串，可以执行的代码

setTimeout ('test()',1000)；       //1秒后执行

匿名函数
setTimeout (function(){},1000)；   //1秒后执行

注：setInterval的用法与setTimeout一样

调用函数，带参数
setTimeout ('test(参数)',1000)；      //1秒后执行

注：如果不小心写成了setTimeout (test(参数),1000)；test方法就会立即执行哦。

-----
function abc (a) {
    console.log(a)
}

setTimeout(abc, 3000) 				//3秒后执行，undefined
setTimeout(abc(), 3000)  			//立即执行，undefined
setTimeout(abc(a), 3000) 			//立即执行，并报错，因为a是参数，a is not defined
setTimeout('abc(a)', 3000)			//3秒后执行，并报错，因为a是参数，a is not defined
setTimeout('abc("a")', 3000) 		//3秒后执行，a 是最为字符传进去








面试题

下面代码运行后的结果是什么？


// 题目一
var t = true;
 
setTimeout(function(){
    t = false;
}, 1000);
 
while(t){}
 
alert('end');

/*--------------------------------*/

// 题目二
for (var i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i);
    }, 0);
}

/*--------------------------------*/

// 题目三
var obj = {
    msg: 'obj',
    shout: function () {
        alert(this.msg);
    },
    waitAndShout: function() {
        setTimeout(function () {
            this.shout();
        }, 0);    
    }
};
obj.waitAndShout();



-----

第一题

alert永远都不会执行，因为JS是单线程的，且定时器的回调将在等待当前正在执行的任务完成后才执行，而while(t) {}直接就进入了死循环一直占用线程，不给回调函数执行机会

第二题

代码会输出 5 5 5 5 5，理由同上，当i = 0时，生成一个定时器，将回调插入到事件队列中，等待当前队列中无任务执行时立即执行，而此时for循环正在执行，所以回调被搁置。当for循环执行完成后，队列中存在着5个回调函数，他们的都将执行console.log(i)的操作，因为当前JS代码上中并没有使用块级作用域，所以i的值在for循环结束后一直为5，所以代码将输出5个5

第三题

这个问题涉及到this的指向问题，由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上. 这会导致这些代码中包含的this关键字会指向window (或全局)对象，window对象中并不存在shout方法，所以就会报错，修改方案如下:

var obj = {
    msg: 'obj',
    shout: function () {
        alert(this.msg);
    },
    waitAndShout: function() {
        var self = this; // 这里将this赋给一个变量
        setTimeout(function () {
            self.shout();
        }, 0);    
    }
};
obj.waitAndShout();

-----


http://caibaojian.com/javascript-timer.html

=====

问题：样式居中

-----
行内元素居中

1.style="text-align:center;"

<div style="border: 1px solid; width:25%;text-align:center">
aaa
</br>

<span>标签行内居中必须要加display: block
因为<a><span>不是块级元素是行内元素，不能够设置元素尺寸，   定义display：block后，设置和长度有关，或者其它的属性才会有效果。

<span style="width:200px;height: 30px;border:1px solid;text-align:center;display:block;">
    bbb
</span>

2.margin:0 auto方式	（行内元素同样要加display）

3.脱离文档流的居中方式。（脱离文档流一般就是说绝对定位）




































伪类


absolute relative

relative（相对定位）：定位原点是元素本身所在位置； 

absolute（绝对定位）：定位原点是离自己这一级元素最近的一级position设置为absolute或者relative的父元素的左上角为原点的
absolute元素进行移动是相对于离它最近的定义了position属性并且属性值不为static的父层元素进行移动（这个父层元素可以不是其直接父层）。如果其父层全部都未定义除static之外的position属性，那么它将相对于html标签元素进行移动。


fixed   
生成绝对定位的元素，相对于浏览器窗口进行定位。 
元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。



定位为relative的元素，虽然可以脱离正常的文档流进行移动，但是其本身在文档流中占据的位置仍然保留。
定位为absolute的元素，也是脱离正常的文档流，并且其本身在文档流中占据的位置不再保留。



static  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。
inherit 规定应该从父元素继承 position 属性的值。




<div 定位>		//随意
	<子div 相对定位>
</div>
//更准确的疑问是，子div的margin-top，会影响父div的位置
（绝对定位能达到预期效果，相对定位此div不动，父级div移动maigin-top）

在父级div 加上	 border: 1px solid transparent;
原因是因为 bfc布局问题。


-----

margin 和  top、right、bottom、left


div 在relative的情况下，盒模型的四类值会影响同级的div（因为absolute脱离了文档流，不占位置）
举个例子：
<div>a</div>
<div>b</div>

a的高度为100px；本来b应该紧接着a排列，即在100px的高度下

如果a设置了margin-top,margin-bottom.border,padding-top,padding-bottom，
那么b的位置还要加上这些属性






如果把div 定义为了行内元素	display: inline-block;
那么使用百分比的时候，left: 10%还有用，但是使用top: 10%,就无效，但是top: 100px;可以使用
我个人认为原因是 本来div是块级元素，默认上下左右填充满父元素，所以%可以使用（因为%相对于父元素）
而被div定义为行内元素了以后，高度就没了，高度只是div的自身高度，
但是可以左右填充满，所以left:10%还可以使用。


position定位最好配合left，right，top，bottom等属性一起使用，不然会出问题。
因为如果绝对定位了，而没有设置top，left等属性，实际位置还在原地。


盒模型结论一：没有（就是没有设置 width 的）宽度的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。


盒模型结论二：为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。








《悟透javascript》

《javascript高级程序设计》